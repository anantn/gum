# HG changeset patch
# Parent 3134bbdeb8a88c2e19813e4e40679397c3ee0383

diff --git a/dom/media/Makefile.in b/dom/media/Makefile.in
--- a/dom/media/Makefile.in
+++ b/dom/media/Makefile.in
@@ -12,20 +12,16 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE           = dom
 XPIDL_MODULE     = dom_media
 LIBRARY_NAME     = dom_media_s
 LIBXUL_LIBRARY   = 1
 FORCE_STATIC_LIB = 1
 FAIL_ON_WARNINGS := 1
 
-ifdef ENABLE_TESTS
-TEST_DIRS += tests
-endif
-
 include $(topsrcdir)/dom/dom-config.mk
 
 EXTRA_COMPONENTS = \
   PeerConnection.js \
   PeerConnection.manifest \
   $(NULL)
 
 XPIDLSRCS = \
diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -14,18 +14,53 @@ Cu.import("resource://gre/modules/identi
 const PC_CONTRACT = "@mozilla.org/dom/peerconnection;1";
 const PC_ICE_CONTRACT = "@mozilla.org/dom/rtcicecandidate;1";
 const PC_SESSION_CONTRACT = "@mozilla.org/dom/rtcsessiondescription;1";
 
 const PC_CID = Components.ID("{7cb2b368-b1ce-4560-acac-8e0dbda7d3d0}");
 const PC_ICE_CID = Components.ID("{8c5dbd70-2c8e-4ecb-a5ad-2fc919099f01}");
 const PC_SESSION_CID = Components.ID("{5f21ffd9-b73f-4ba0-a685-56b4667aaf1c}");
 
-function IceCandidate() {
-  this.candidate = null;
+// Global list of PeerConnection objects, so they can be cleaned up when
+// a page is torn down. (Maps outer window ID to an array of PC objects).
+function GlobalPCList() {
+  this._list = {};
+  Services.obs.addObserver(this, "outer-window-destroyed", true);
+}
+GlobalPCList.prototype = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
+                                         Ci.nsISupportsWeakReference]),
+
+  addPC: function(pc) {
+    let winID = pc._winID;
+    if (this._list[winID]) {
+      this._list[winID].push(pc);
+    } else {
+      this._list[winID] = [pc];
+    }
+  },
+
+  observe: function(subject, topic, data) {
+    if (topic != "outer-window-destroyed") {
+      return;
+    }
+    let winID = subject.QueryInterface(Ci.nsISupportsPRUint64).data;
+    if (this._list[winID]) {
+      this._list[winID].forEach(function(pc) {
+        pc._pc.close();
+        delete pc._observer;
+      });
+      delete this._list[winID];
+    }
+  }
+};
+let _globalPCList = new GlobalPCList();
+
+function IceCandidate(candidate) {
+  this.candidate = candidate;
   this.sdpMid = null;
   this.sdpMLineIndex = null;
 }
 IceCandidate.prototype = {
   classID: PC_ICE_CID,
 
   classInfo: XPCOMUtils.generateCI({classID: PC_ICE_CID,
                                     contractID: PC_ICE_CONTRACT,
@@ -43,19 +78,19 @@ IceCandidate.prototype = {
   constructor: function(win, cand, mid, mline) {
     this._win = win;
     this.candidate = cand;
     this.sdpMid = mid;
     this.sdpMLineIndex = mline;
   }
 };
 
-function SessionDescription() {
-  this.type = null;
-  this.sdp = null;
+function SessionDescription(type, sdp) {
+  this.type = type;
+  this.sdp = sdp;
 }
 SessionDescription.prototype = {
   classID: PC_SESSION_CID,
 
   classInfo: XPCOMUtils.generateCI({classID: PC_SESSION_CID,
                                     contractID: PC_SESSION_CONTRACT,
                                     classDescription: "SessionDescription",
                                     interfaces: [
@@ -83,33 +118,38 @@ SessionDescription.prototype = {
 
 function PeerConnection() {
   this._queue = [];
 
   this._pc = null;
   this._observer = null;
   this._identity = null;
 
-  // TODO: Refactor this.
   this._onCreateOfferSuccess = null;
   this._onCreateOfferFailure = null;
   this._onCreateAnswerSuccess = null;
   this._onCreateAnswerFailure = null;
-  this._onSelectIdentitySuccess = null;
-  this._onSelectIdentityFailure = null;
-  this._onVerifyIdentitySuccess = null;
-  this._onVerifyIdentityFailure = null;
 
-  // Everytime we get a request from content, we put it in the queue. If
-  // there are no pending operations though, we will execute it immediately.
-  // In PeerConnectionObserver, whenever we are notified that an operation
-  // has finished, we will check the queue for the next operation and execute
-  // if neccesary. The _pending flag indicates whether an operation is currently
-  // in progress.
+  /**
+   * Everytime we get a request from content, we put it in the queue. If
+   * there are no pending operations though, we will execute it immediately.
+   * In PeerConnectionObserver, whenever we are notified that an operation
+   * has finished, we will check the queue for the next operation and execute
+   * if neccesary. The _pending flag indicates whether an operation is currently
+   * in progress.
+   */
   this._pending = false;
+
+  // Public attributes.
+  this.onaddstream = null;
+  this.onremovestream = null;
+  this.onicecandidate = null;
+  this.onstatechange = null;
+  this.ongatheringchange = null;
+  this.onicechange = null;
 }
 PeerConnection.prototype = {
   classID: PC_CID,
 
   classInfo: XPCOMUtils.generateCI({classID: PC_CID,
                                     contractID: PC_CONTRACT,
                                     classDescription: "PeerConnection",
                                     interfaces: [
@@ -117,202 +157,96 @@ PeerConnection.prototype = {
                                       Ci.nsIDOMGlobalObjectConstructor
                                     ],
                                     flags: Ci.nsIClassInfo.DOM_OBJECT}),
 
   QueryInterface: XPCOMUtils.generateQI([
     Ci.nsIDOMRTCPeerConnection, Ci.nsIDOMGlobalObjectConstructor
   ]),
 
-  // Constructor is an explicit function, because of nsIDOMGlobalObjectConstructor
+  // Constructor is an explicit function, because of nsIDOMGlobalObjectConstructor.
   constructor: function(win) {
     this._pc = Cc["@mozilla.org/peerconnection;1"].
              createInstance(Ci.IPeerConnection);
     this._observer = new PeerConnectionObserver(this);
 
-    this._uniqId = Cc["@mozilla.org/uuid-generator;1"]
-                   .getService(Ci.nsIUUIDGenerator)
-                   .generateUUID().toString();
-
     // Nothing starts until ICE gathering completes.
     this._queueOrRun({
       func: this._pc.initialize,
       args: [this._observer, win, Services.tm.currentThread],
       wait: true
     });
-    this._printQueue();
 
     this._win = win;
     this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
 
-    dump("!!! mozPeerConnection constructor called " + this._win + "\n");
+    // Add a reference to the PeerConnection to global list.
+    _globalPCList.addPC(this);
   },
 
-  // FIXME: Right now we do not enforce proper invocation (eg: calling
-  // createOffer twice in a row is allowed).
-
-  _printQueue: function() {
-    let q = "!!! Queue for " + this._uniqId + " is currently: [";
-    for (let i = 0; i < this._queue.length; i++) {
-      q = q + this._queue[i].func.name + ",";
-    }
-    q += "]\n";
-    dump(q);
-  },
-
-  // Add a function to the queue or run it immediately if the queue is empty.
-  // Argument is an object with the func, args and wait properties; wait should
-  // be set to true if the function has a success/error callback that will
-  // call _executeNext, false if it doesn't have a callback.
+  /**
+   * Add a function to the queue or run it immediately if the queue is empty.
+   * Argument is an object with the func, args and wait properties; wait should
+   * be set to true if the function has a success/error callback that will
+   * call _executeNext, false if it doesn't have a callback.
+   */
   _queueOrRun: function(obj) {
     if (!this._pending) {
-      dump("!!! " + this._uniqId + " : calling " + obj.func.name + "\n");
       obj.func.apply(this, obj.args);
       if (obj.wait) {
         this._pending = true;
       }
     } else {
-      dump("!!! " + this._uniqId + " : queued " + obj.func.name + "\n");
       this._queue.push(obj);
     }
-    this._printQueue();
   },
 
-  // Pick the next item from the queue and run it
+  // Pick the next item from the queue and run it.
   _executeNext: function() {
-    dump("!!! in executeNext: ");
-    this._printQueue();
     if (this._queue.length) {
       let obj = this._queue.shift();
       obj.func.apply(this, obj.args);
       if (!obj.wait) {
         this._executeNext();
       }
     } else {
       this._pending = false;
     }
   },
 
-  _selectIdentity: function() {
-    let self = this;
-    IDService.selectIdentity(this._uniqId, this._winID, function(err, val) {
-      if (err) {
-        self._onSelectIdentityFailure.onCallback(err);
-      } else {
-        self._identity = val;
-        self._onSelectIdentitySuccess.onCallback(null);
-      }
-      self._executeNext();
-    });
-  },
-
-  _displayVerification: function(email) {
-    let browser = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
-                         .getInterface(Ci.nsIWebNavigation)
-                         .QueryInterface(Ci.nsIDocShell).chromeEventHandler;
-    let chromeWin = browser.ownerDocument.defaultView;
-
-    dump("going to show identity popup\n");
-
-    chromeWin.PopupNotifications.show(
-      browser, "webrtc-id-verified",
-      "This call has been verified as originating from " + email,
-      "password-notification-icon", // temporary
-      {
-        label: "Ok", accessKey: "o", callback: function() {}
-      },
-      [], {dismissed:true}
-    );
-  },
-
-  _verifyIdentity: function(offer) {
-    let self = this;
-
-    // Extract the a=fingerprint and a=identity lines.
-    let ire = new RegExp("a=identity:(.+)\r\n");
-    let fre = new RegExp("a=fingerprint:(.+)\r\n");
-
-    let id = offer.sdp.match(ire);
-    let fprint = offer.sdp.match(fre);
-
-    dump("!!! "+ this._uniqId + " : fprint = " + fprint[1] + "\n");
-
-    if (id.length == 2 && fprint.length == 2) {
-      IDService.verifyIdentity(id[1], function(err, val) {
-        if (!val) {
-          dump("!!! : no verified value\n");
-          dump("!!! : err =" + err + "\n");
-        } else {
-          dump("!!! : verified value = " + val.message + "\n");
-        }
-
-        if (val && (fprint[1] == val.message)) {
-          dump("!!! : got from verifyIdentity: " + JSON.stringify(val));
-          val.__exposedProps__ = {
-            aud: "rw", message: "rw", iss: "rw", exp: "rw", iat: "rw",
-            principal: "rw"
-          };
-          self._onVerifyIdentitySuccess.onCallback(val);
-          self._displayVerification(val.principal.email);
-
-          // If the fingerprint was valid, set the remote fingerprint in the
-          // local PeerConnectionImpl
-          let fingerprint = fprint[1].split(" "); // sha-1 xx:xx:xx:...
-          self._pc.setRemoteFingerprint(fingerprint[0], fingerprint[1]);
-          return;
-        }
-        self._onVerifyIdentityFailure.onCallback(err || "Signed message did not match");
-      });
-    } else {
-      self._onVerifyIdentityFailure.onCallback("No identity information found");
-    }
-  },
-
-  selectIdentity: function(onSuccess, onError) {
-    dump("!!! " + this._uniqId + " : selectIdentity called\n");
-    this._onSelectIdentitySuccess = onSuccess;
-    this._onSelectIdentityFailure = onError;
-
-    this._queueOrRun({func: this._selectIdentity, args: null, wait: true});
-    dump("!!! "+ this._uniqId + " :  selectIdentity returned\n");
-  },
-
-  verifyIdentity: function(offer, onSuccess, onError) {
-    dump("!!! " + this._uniqId + " : verifyIdentity called\n");
-    this._onVerifyIdentitySuccess = onSuccess;
-    this._onVerifyIdentityFailure = onError;
-
-    if (!offer.type || !offer.sdp) {
+  createOffer: function(onSuccess, onError, constraints) {
+    if (this._onCreateOfferSuccess) {
       if (onError) {
-        onError.onCallback("Invalid offer/answer provided to verifyIdentity");
+        onError.onCallback("createOffer already called");
       }
       return;
     }
 
-    this._queueOrRun({func: this._verifyIdentity, args: [offer], wait: true});
-    dump("!!! " + this._uniqId + " : verifyIdentity returned\n");
-  },
-
-  createOffer: function(onSuccess, onError, constraints) {
-    dump("!!! " + this._uniqId + " : createOffer called\n");
     this._onCreateOfferSuccess = onSuccess;
     this._onCreateOfferFailure = onError;
 
     // TODO: Implement constraints/hints.
     if (!constraints) {
       constraints = "";
     }
 
-    this._queueOrRun({func: this._pc.createOffer, args: [constraints], wait: true});
-    dump("!!! " + this._uniqId + " : createOffer returned\n");
+    this._queueOrRun({
+      func: this._pc.createOffer, args: [constraints], wait: true
+    });
   },
 
   createAnswer: function(offer, onSuccess, onError, constraints, provisional) {
-    dump("!!! " + this._uniqId + " : createAnswer called\n");
+    if (this._onCreateAnswerSuccess) {
+      if (onError) {
+        onError.onCallback("createAnswer already called");
+      }
+      return;
+    }
+
     this._onCreateAnswerSuccess = onSuccess;
     this._onCreateAnswerFailure = onError;
 
     if (offer.type != "offer") {
       if (onError) {
         onError.onCallback("Invalid type " + offer.type + " passed");
       }
       return;
@@ -328,365 +262,282 @@ PeerConnection.prototype = {
     if (!constraints) {
       constraints = "";
     }
     if (!provisional) {
       provisional = false;
     }
 
     // TODO: Implement provisional answer & constraints.
-    this._queueOrRun({func: this._pc.createAnswer, args: ["", offer.sdp], wait: true});
-    dump("!!! " + this._uniqId + " : createAnswer returned\n");
+    this._queueOrRun({
+      func: this._pc.createAnswer, args: ["", offer.sdp], wait: true
+    });
   },
 
   setLocalDescription: function(desc, onSuccess, onError) {
+    if (this._onSetLocalDescriptionSuccess) {
+      if (onError) {
+        onError.onCallback("setLocalDescription already called");
+      }
+      return;
+    }
+
     this._onSetLocalDescriptionSuccess = onSuccess;
     this._onSetLocalDescriptionFailure = onError;
 
     let type;
     switch (desc.type) {
       case "offer":
         type = Ci.IPeerConnection.kActionOffer;
         break;
       case "answer":
         type = Ci.IPeerConnection.kActionAnswer;
         break;
       default:
         if (onError) {
-          onError.onCallback("Invalid type " + desc.type + " provided to setLocalDescription");
+          onError.onCallback(
+            "Invalid type " + desc.type + " provided to setLocalDescription"
+          );
           return;
         }
         break;
     }
 
-    dump("!!! " + this._uniqId + " : setLocalDescription called\n");
-    this._queueOrRun({func: this._pc.setLocalDescription, args: [type, desc.sdp], wait: true});
-    dump("!!! " + this._uniqId + " : setLocalDescription returned\n");
+    this._queueOrRun({
+      func: this._pc.setLocalDescription, args: [type, desc.sdp], wait: true
+    });
   },
 
   setRemoteDescription: function(desc, onSuccess, onError) {
+    if (this._onSetRemoteDescriptionSuccess) {
+      if (onError) {
+        onError.onCallback("setRemoteDescription already called");
+      }
+      return;
+    }
+
     this._onSetRemoteDescriptionSuccess = onSuccess;
     this._onSetRemoteDescriptionFailure = onError;
 
     let type;
     switch (desc.type) {
       case "offer":
         type = Ci.IPeerConnection.kActionOffer;
         break;
       case "answer":
         type = Ci.IPeerConnection.kActionAnswer;
         break;
       default:
         if (onError) {
-          onError.onCallback("Invalid type " + desc.type + " provided to setLocalDescription");
+          onError.onCallback(
+            "Invalid type " + desc.type + " provided to setLocalDescription"
+          );
           return;
         }
         break;
     }
 
-    dump("!!! " + this._uniqId + " : setRemoteDescription called\n");
-    this._queueOrRun({func: this._pc.setRemoteDescription, args: [type, desc.sdp], wait: true});
-    dump("!!! " + this._uniqId + " : setRemoteDescription returned\n");
+    this._queueOrRun({
+      func: this._pc.setRemoteDescription, args: [type, desc.sdp], wait: true
+    });
   },
 
   updateIce: function(config, constraints, restart) {
     return Cr.NS_ERROR_NOT_IMPLEMENTED;
   },
 
-  addIceCandidate: function(candidate) {
-    return Cr.NS_ERROR_NOT_IMPLEMENTED;
+  addIceCandidate: function(cand) {
+    if (!cand) {
+      throw "Invalid candidate passed to addIceCandidate!";
+    }
+    if (!cand.candidate || !cand.sdpMid || !cand.sdpMLineIndex) {
+      throw "Invalid candidate passed to addIceCandidate!";
+    }
+
+    this._queueOrRun({
+      func: this._pc.addIceCandidate,
+      args: [cand.candidate, cand.sdpMid, cand.sdpMLineIndex], wait: false
+    });
   },
 
   addStream: function(stream, constraints) {
-    dump("!!! " + this._uniqId + " : addStream " + stream + " called\n");
     // TODO: Implement constraints.
     this._queueOrRun({func: this._pc.addStream, args: [stream], wait: false});
-    dump("!!! " + this._uniqId + " : addStream returned\n");
   },
 
   removeStream: function(stream) {
-    dump("!!! " + this._uniqId + " : removeStream called\n");
     this._queueOrRun({func: this._pc.removeStream, args: [stream], wait: false});
-    dump("!!! " + this._uniqId + " : removeStream returned\n");
-  },
-
-  createDataChannel: function(label, dict) {
-    dump("!!! " + this._uniqId + " : createDataChannel called\n");
-    if (dict.maxRetransmitTime != undefined &&
-        dict.maxRetransmitNum != undefined) {
-      // throw error
-    }
-
-    // must determine the type where we still know if entries are undefined
-    let type;
-    if (dict.maxRetransmitTime != undefined) {
-      type = Ci.IPeerConnection.DATACHANNEL_PARTIAL_RELIABLE_TIMED;
-    } else if (dict.maxRetransmitNum != undefined) {
-      type = Ci.IPeerConnection.DATACHANNEL_PARTIAL_RELIABLE_REXMIT;
-    } else {
-      type = Ci.IPeerConnection.DATACHANNEL_RELIABLE;
-    }
-
-    // FIXME: _queueOrRun this, why is this synchronous?
-    let channel = this._pc.createDataChannel(
-      label, type, dict.outOfOrderAllowed, dict.maxRetransmitTime,
-      dict.maxRetransmitNum
-    );
-    dump("!!! " + this._uniqId + " : createDataChannel returned\n");
-    return channel;
-  },
-
-  connectDataConnection: function(localport, remoteport, numstreams) {
-    dump("!!! " + this._uniqId + " : ConnectDataConnection() called\n");
-    if (numstreams == undefined || numstreams <= 0) {
-      numstreams = 16;
-    }
-    this._queueOrRun({func: this._pc.connectDataConnection, args: [localport, remoteport, numstreams], wait: false});
-    dump("!!! " + this._uniqId + " : ConnectDataConnection() returned\n");
-  },
-
-  // FIX - remove connect() and listen()
-  listen: function(port, numstreams) {
-    dump("!!! " + this._uniqId + " : listen() called\n");
-    if (numstreams == undefined || numstreams <= 0) {
-      numstreams = 16;
-    }
-    this._queueOrRun({func: this._pc.listen, args: [port, numstreams], wait: false});
-    dump("!!! " + this._uniqId + " : listen() returned\n");
-  },
-
-  connect: function(addr, localport, remoteport, numstreams) {
-    dump("!!! " + this._uniqId + " : connect() called\n");
-    if (numstreams == undefined || numstreams <= 0) {
-      numstreams = 16;
-    }
-    this._queueOrRun({func: this._pc.connect, args: [addr, localport, remoteport, numstreams], wait: false});
-    dump("!!! " + this._uniqId + " : connect() returned\n");
-  },
-
-  close: function() {
-    dump("!!! " + this._uniqId + " : close called\n");
-    // Don't queue this one, since we just want to shutdown.
-    this._pc.closeStreams();
-    this._pc.close();
-
-    this._queue = [];
-    this._pending = true;
-    dump("!!! " + this._uniqId + " : close returned");
-  },
-
-  onaddstream: null,
-  notifyDataChannel: null,
-  notifyConnection: null,
-  notifyClosedConnection: null,
-
-  // For testing only.
-  createFakeMediaStream: function(type, muted) {
-    var hint_mute = muted ? 0x80 : 0;
-    if (type == "video") {
-      return this._pc.createFakeMediaStream(Ci.IPeerConnection.kHintVideo |
-                                            hint_mute);
-    }
-    return this._pc.createFakeMediaStream(Ci.IPeerConnection.kHintAudio |
-                                          hint_mute);
   }
 };
 
 // This is a seperate object because we don't want to expose it to DOM.
 function PeerConnectionObserver(dompc) {
   this._dompc = dompc;
 }
 PeerConnectionObserver.prototype = {
   QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
 
   onCreateOfferSuccess: function(offer) {
-    dump("!!! " + this._dompc._uniqId + " : onCreateOfferSuccess called\n");
-
-    // Before calling the success callback, check if selectIdentity was
-    // previously called and that an identity was obtained. If so, add
-    // a signed string to the SDP before sending it to content.
-    if (!this._dompc._identity) {
-      this._dompc._onCreateOfferSuccess.onCallback({
-        type: "offer", sdp: offer,
-        __exposedProps__: { type: "rw", sdp: "rw" }
-      });
-      this._dompc._executeNext();
-      return;
+    if (this._dompc._onCreateOfferSuccess) {
+      try {
+        this._dompc._onCreateOfferSuccess.onCallback({
+          type: "offer", sdp: offer,
+          __exposedProps__: { type: "rw", sdp: "rw" }
+        });
+      } catch(e) {}
     }
-
-    let sig = this._dompc._pc.fingerprint;
-    dump("!!! " + this._dompc._uniqId + " : fingerprint = " + sig + "\n");
-
-    // FIXME! Save the origin of the window that created the dompc.
-    let self = this;
-    this._dompc._identity.sign("http://example.org", sig, function(e, ast) {
-      if (e && self._dompc._onCreateOfferFailure) {
-        self._dompc._onCreateOfferFailure(e);
-        self._dompc._executeNext();
-        return;
-      }
-
-      // Got assertion, add to the SDP along with the fingerprint. We put
-      // it right at the top, because these must come before the first
-      // m= line.
-      let sigline = "a=fingerprint:" + sig + "\r\n";
-      let idline = "a=identity:" + ast + "\r\n";
-
-      let parts = offer.split("m=");
-      let finalOffer = parts[0] + idline;
-      for (let i = 1; i < parts.length; i++) {
-        finalOffer += "m=" + parts[i];
-      }
-
-      dump("!!! " + self._dompc._uniqId + " : Generated final offer: " + finalOffer + "\n\n");
-      self._dompc._onCreateOfferSuccess.onCallback({
-        type: "offer", sdp: finalOffer,
-        __exposedProps__: { type: "rw", sdp: "rw" }
-      });
-      self._dompc._executeNext();
-    });
+    this._dompc._executeNext();
   },
 
   onCreateOfferError: function(code) {
-    dump("!!! " + this._dompc._uniqId + " : onCreateOfferError called: " + code + "\n");
     if (this._dompc._onCreateOfferFailure) {
-      this._dompc._onCreateOfferFailure.onCallback(code);
+      try {
+        this._dompc._onCreateOfferFailure.onCallback(code);
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
   onCreateAnswerSuccess: function(answer) {
-    dump("!!! " + this._dompc._uniqId + " : onCreateAnswerSuccess called\n");
     if (this._dompc._onCreateAnswerSuccess) {
-      this._dompc._onCreateAnswerSuccess.onCallback({
-        type: "answer", sdp: answer,
-        __exposedProps__: { type: "rw", sdp: "rw" }
-      });
+      try {
+        this._dompc._onCreateAnswerSuccess.onCallback({
+          type: "answer", sdp: answer,
+          __exposedProps__: { type: "rw", sdp: "rw" }
+        });
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
   onCreateAnswerError: function(code) {
-    dump("!!! " + this._dompc._uniqId + " : onCreateAnswerError called: " + code + "\n");
     if (this._dompc._onCreateAnswerFailure) {
-      this._dompc._onCreateAnswerFailure.onCallback(code);
+      try {
+        this._dompc._onCreateAnswerFailure.onCallback(code);
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
   onSetLocalDescriptionSuccess: function(code) {
-    dump("!!! " + this._dompc._uniqId + " : onSetLocalDescriptionSuccess called\n");
     if (this._dompc._onSetLocalDescriptionSuccess) {
-      this._dompc._onSetLocalDescriptionSuccess.onCallback(code);
+      try {
+        this._dompc._onSetLocalDescriptionSuccess.onCallback(code);
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
   onSetRemoteDescriptionSuccess: function(code) {
-    dump("!!! " + this._dompc._uniqId + " : onSetRemoteDescriptionSuccess called\n");
     if (this._dompc._onSetRemoteDescriptionSuccess) {
-      this._dompc._onSetRemoteDescriptionSuccess.onCallback(code);
+      try {
+        this._dompc._onSetRemoteDescriptionSuccess.onCallback(code);
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
   onSetLocalDescriptionError: function(code) {
-    dump("!!! " + this._dompc._uniqId + " : onSetLocalDescriptionError called: " + code + "\n");
     if (this._dompc._onSetLocalDescriptionFailure) {
-      this._dompc._onSetLocalDescriptionFailure.onCallback(code);
+      try {
+        this._dompc._onSetLocalDescriptionFailure.onCallback(code);
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
   onSetRemoteDescriptionError: function(code) {
-    dump("!!! " + this._dompc._uniqId + " : onSetRemoteDescriptionError called: " + code + "\n");
     if (this._dompc._onSetRemoteDescriptionFailure) {
       this._dompc._onSetRemoteDescriptionFailure.onCallback(code);
     }
     this._dompc._executeNext();
   },
 
-  // FIXME: Following observer events should update state on this._dompc.
   onStateChange: function(state) {
-    dump("!!! " + this._dompc._uniqId + " : onStateChange called: " + state + "\n");
-
     if (state != Ci.IPeerConnectionObserver.kIceState) {
       return;
     }
 
+    let self = this;
+    let iceCb = function() {};
+    let iceGatherCb = function() {};
+    if (this._dompc.onicechange) {
+      iceCb = function(args) {
+        try {
+          self._dompc.onicechange(args);
+        } catch(e) {}
+      };
+    }
+    if (this._dompc.ongatheringchange) {
+      iceGatherCb = function(args) {
+        try {
+          self._dompc.ongatheringchange(args);
+        } catch(e) {}
+      };
+    }
+
     switch (this._dompc._pc.iceState) {
+      case Ci.IPeerConnection.kIceGathering:
+        iceGatherCb("gathering");
+        break;
       case Ci.IPeerConnection.kIceWaiting:
-        dump("!!! ICE waiting...\n");
+        iceCb("starting");
         this._dompc._executeNext();
         break;
       case Ci.IPeerConnection.kIceChecking:
-        dump("!!! ICE checking...\n");
+        iceCb("checking");
         this._dompc._executeNext();
         break;
       case Ci.IPeerConnection.kIceConnected:
-        dump("!!! " + this._dompc._uniqId + " : ICE gathering is complete, calling _executeNext! \n");
+        // ICE gathering complete.
+        iceCb("connected");
+        iceGatherCb("complete");
         this._dompc._executeNext();
         break;
+      case Ci.IPeerConnection.kIceFailed:
+        iceCb("failed");
+        break;
       default:
-        dump("!!! " + this._dompc._uniqId + " : ICE invalid state, " + this._dompc._pc.iceState + "\n");
+        // Unknown state!
         break;
     }
   },
 
   onAddStream: function(stream, type) {
-    dump("!!! " + this._dompc._uniqId + " : onAddStream called: " + stream + " :: " + type + "\n");
     if (this._dompc.onaddstream) {
-      this._dompc.onaddstream.onCallback({
-        stream: stream, type: type,
-        __exposedProps__: { stream: "r", type: "r" }
-      });
+      try {
+        this._dompc.onaddstream.onCallback({
+          stream: stream, type: type,
+          __exposedProps__: { stream: "r", type: "r" }
+        });
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
-  onRemoveStream: function() {
-    dump("!!! " + this._dompc._uniqId + " : onRemoveStream called\n");
-    this._dompc._executeNext();
-  },
-
-  onAddTrack: function() {
-    dump("!!! " + this._dompc._uniqId + " : onAddTrack called\n");
-    this._dompc._executeNext();
-  },
-
-  onRemoveTrack: function() {
-    dump("!!! " + this._dompc._uniqId + " : onRemoveTrack called\n");
-    this._dompc._executeNext();
-  },
-
-  notifyConnection: function() {
-    dump("!!! " + this._dompc._uniqId + " : onConnection called\n");
-    if (this._dompc.onConnection) {
-      this._dompc.onConnection.onCallback();
+  onRemoveStream: function(stream, type) {
+    if (this._dompc.onremovestream) {
+      try {
+        this._dompc.onremovestream.onCallback({
+          stream: stream, type: type,
+          __exposedProps__: { stream: "r", type: "r" }
+        });
+      } catch(e) {}
     }
     this._dompc._executeNext();
   },
 
-  notifyClosedConnection: function() {
-    dump("!!! " + this._dompc._uniqId + " : onClosedConnection called\n");
-    if (this._dompc.onClosedConnection) {
-      this._dompc.onClosedConnection.onCallback();
+  foundIceCandidate: function(cand) {
+    if (this._dompc.onicecandidate) {
+      try {
+        this._dompc.onicecandidate.onCallback({
+          candidate: cand,
+          __exposedProps__: { candidate: "rw" }
+        });
+      } catch(e) {}
     }
     this._dompc._executeNext();
-  },
-
-  notifyDataChannel: function(channel) {
-    dump("!!! " + this._dompc._uniqId + " : onDataChannel called: " + channel + "\n");
-    if (this._dompc.onDataChannel) {
-      this._dompc.onDataChannel.onCallback(channel);
-    }
-    this._dompc._executeNext();
-  },
-
-  foundIceCandidate: function(candidate) {
-    dump("!!! " + this._dompc._uniqId + " : foundIceCandidate called: " + candidate + "\n");
-    this._dompc._executeNext();
   }
 };
 
 let NSGetFactory = XPCOMUtils.generateNSGetFactory(
   [IceCandidate, SessionDescription, PeerConnection]
 );
diff --git a/dom/media/bridge/IPeerConnection.idl b/dom/media/bridge/IPeerConnection.idl
--- a/dom/media/bridge/IPeerConnection.idl
+++ b/dom/media/bridge/IPeerConnection.idl
@@ -1,14 +1,12 @@
 #include "nsIThread.idl"
 #include "nsIDOMWindow.idl"
 
-interface nsIDOMDataChannel;
 interface nsIDOMMediaStream;
-interface nsIDOMWindow;
 
 /* Do not confuse with nsIDOMRTCPeerConnection. This interface is purely for
  * communication between the PeerConnection JS DOM binding and the C++
  * implementation in SIPCC.
  *
  * See media/webrtc/signaling/include/PeerConnectionImpl.h
  */
 [scriptable, uuid(84efc76f-41d9-496a-9444-2965d179d419)]
@@ -34,21 +32,16 @@ interface IPeerConnectionObserver : nsIS
   void onStateChange(in unsigned long state);
 
   /* Changes to MediaStreams */
   void onAddStream(in nsIDOMMediaStream stream, in string type);
   void onRemoveStream();
   void onAddTrack();
   void onRemoveTrack();
 
-  /* DataChannel observers */
-  void notifyConnection();
-  void notifyClosedConnection();
-  void notifyDataChannel(in nsIDOMDataChannel channel);
-
   /* When SDP is parsed and a candidate line is found this method is called.
    * It should hook back into the media transport to notify it of ICE candidates
    * listed in the SDP PeerConnectionImpl does not parse ICE candidates, just
    * pulls them out of the SDP.
    */
   void foundIceCandidate(in string candidate);
 };
 
@@ -64,23 +57,18 @@ interface IPeerConnection : nsISupports
   const long kActionPRAnswer = 2;
 
   const long kIceGathering = 0;
   const long kIceWaiting = 1;
   const long kIceChecking = 2;
   const long kIceConnected = 3;
   const long kIceFailed = 4;
 
-  /* for 'type' in DataChannelInit dictionary */
-  const unsigned short DATACHANNEL_RELIABLE=0;
-  const unsigned short DATACHANNEL_PARTIAL_RELIABLE_REXMIT=1;
-  const unsigned short DATACHANNEL_PARTIAL_RELIABLE_TIMED=2;
-
   /* Must be called first. Observer events will be dispatched on the thread provided */
-  void initialize(in IPeerConnectionObserver observer, in nsIDOMWindow window, 
+  void initialize(in IPeerConnectionObserver observer, in nsIDOMWindow window,
                   [optional] in nsIThread thread);
 
   /* JSEP calls */
   void createOffer(in string hints);
   void createAnswer(in string hints, in string offer);
   void setLocalDescription(in long action, in string sdp);
   void setRemoteDescription(in long action, in string sdp);
 
@@ -94,35 +82,16 @@ interface IPeerConnection : nsISupports
    * call PeerConnectionImpl does not parse ICE candidates, just sticks them
    * into the SDP.
    */
   void addIceCandidate(in string candidate, in string mid, in unsigned short level);
 
   /* Puts the SIPCC engine back to 'kIdle', shuts down threads, deletes state */
   void close();
 
-  /* For testing purposes only! */
-  nsIDOMMediaStream createFakeMediaStream(in unsigned long hint);
-
-  /* Bring up SCTP/DTLS/UDP connection*/
-  void connectDataConnection(in unsigned short localport, in unsigned short remoteport, in unsigned short numstreams);
-  nsIDOMDataChannel createDataChannel(in ACString label,
-                                      in unsigned short type,
-                                      in boolean outOfOrderAllowed,
-                                      in unsigned short maxTime,
-                                      in unsigned short maxNum);
-
-  /* XXX remove these */
-  void listen(in unsigned short port, in unsigned short numstreams);
-  void connect(in DOMString addr, in unsigned short localport, in unsigned short remoteport, in unsigned short numstreams);
-
-  /* For identity */
-  readonly attribute string fingerprint;
-  void setRemoteFingerprint(in string hash, in string fingerprint);
-
   /* Attributes */
   readonly attribute string localDescription;
   readonly attribute string remoteDescription;
 
   readonly attribute unsigned long iceState;
   readonly attribute unsigned long readyState;
   readonly attribute unsigned long sipccState;
 };
diff --git a/dom/media/nsIDOMRTCPeerConnection.idl b/dom/media/nsIDOMRTCPeerConnection.idl
--- a/dom/media/nsIDOMRTCPeerConnection.idl
+++ b/dom/media/nsIDOMRTCPeerConnection.idl
@@ -1,18 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 #include "nsIDOMMediaStream.idl"
 
-interface nsIDOMEventListener;
-interface nsIDOMDataChannel;
-
 [scriptable, function, uuid(eb9c563c-3b09-4565-9317-eca96ae0c538)]
 interface RTCPeerConnectionCallback : nsISupports
 {
   void onCallback(in jsval value);
 };
 
 [scriptable, function, uuid(55546efd-287b-4460-8283-0592875b890f)]
 interface RTCPeerConnectionCallbackVoid : nsISupports
@@ -30,27 +27,16 @@ interface nsIDOMRTCSessionDescription : 
 [scriptable, uuid(df176474-e20a-4f42-a85b-b0414d634cf0)]
 interface nsIDOMRTCIceCandidate : nsISupports
 {
   attribute DOMString candidate;
   attribute DOMString sdpMid;
   attribute unsigned short sdpMLineIndex;
 };
 
-/* If either maxRetransmitTime or maxRetransmitNum are set, it's
-   unreliable, else it's a reliable channel.  If both are set it's an
-   error.  outOfOrderAllowed can be used with any type of channel.  The
-   equivalent of UDP is { outOfOrderAllowed: true, maxRetransmitNum: 0 }.
-   The TCP equivalent is {}. */
-dictionary DataChannelInit {
-  boolean outOfOrderAllowed;
-  unsigned short maxRetransmitTime;
-  unsigned short maxRetransmitNum;
-};
-
 /* See http://dev.w3.org/2011/webrtc/editor/webrtc.html */
 [scriptable, uuid(94628e70-e96f-4170-871c-f993a49f065a)]
 interface nsIDOMRTCPeerConnection : nsISupports
 {
   void createOffer(in RTCPeerConnectionCallback successCallback,
     [optional] in RTCPeerConnectionCallback failureCallback,
     [optional] in jsval constraints);
 
@@ -93,37 +79,9 @@ interface nsIDOMRTCPeerConnection : nsIS
 
   /* Event handlers. TODO: Use real EventTarget */
   attribute RTCPeerConnectionCallback onaddstream;
   attribute RTCPeerConnectionCallback onremovestream;
   attribute RTCPeerConnectionCallback onicecandidate;
   attribute RTCPeerConnectionCallback onstatechange;
   attribute RTCPeerConnectionCallback ongatheringchange;
   attribute RTCPeerConnectionCallback onicechange;
-
-  /* Identity */
-  void selectIdentity(in RTCPeerConnectionCallback successCallback,
-    [optional] in RTCPeerConnectionCallback failureCallback);
-
-  void verifyIdentity(in jsval offer,
-    in RTCPeerConnectionCallback successCallback,
-    in RTCPeerConnectionCallback failureCallback);
-
-  /* Data channel */
-  nsIDOMDataChannel createDataChannel([optional] in ACString label,
-                                      /* DataChannelInit */ [optional] in jsval options);
-  attribute RTCPeerConnectionCallbackVoid onConnection;
-  attribute RTCPeerConnectionCallbackVoid onClosedConnection;
-  attribute RTCPeerConnectionCallback onDataChannel;
-
-  /* For purposes only! Remove in production */
-  nsIDOMMediaStream createFakeMediaStream(in string type,
-                                          [optional] in boolean mute
-                                          );
-
-  /* Bring up SCTP/DTLS/UDP connection */
-  /* XXX remove */
-  void connectDataConnection(in unsigned short localport, in unsigned short remoteport,
-                             [optional] in unsigned short numstreams);
-  void listen(in unsigned short port, [optional] in unsigned short numstreams);
-  void connect(in DOMString addr, in unsigned short localport, in unsigned short remoteport,
-               [optional] in unsigned short numstreams);
 };
diff --git a/dom/media/tests/Makefile.in b/dom/media/tests/Makefile.in
deleted file mode 100644
--- a/dom/media/tests/Makefile.in
+++ /dev/null
@@ -1,16 +0,0 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this file,
-# You can obtain one at http://mozilla.org/MPL/2.0/.
-
-DEPTH     = ../../..
-topsrcdir = @top_srcdir@
-srcdir    = @srcdir@
-VPATH     = @srcdir@
-relativesrcdir = dom/media/tests
-
-include $(DEPTH)/config/autoconf.mk
-
-MODULE = test_dom_media
-XPCSHELL_TESTS = unit
-
-include $(topsrcdir)/config/rules.mk
diff --git a/dom/media/tests/local_audio_test.html b/dom/media/tests/local_audio_test.html
deleted file mode 100644
--- a/dom/media/tests/local_audio_test.html
+++ /dev/null
@@ -1,107 +0,0 @@
-<html>
-<head>
-  <title>Simple PeerConnection Test</title>
-</head>
-<body>
-
-<h1>Simple PeerConnection Test</h1>
-<div><audio id="tehaudio" controls></audio></div><br/>
-<div><button id="tehbutton" onClick="start();">Start!</button></div><br/>
-<div id="log"></div>
-<div><audio id="localaudio" muted></audio></div><br/>
-
-<script type="application/javascript;version=1.8">
-  function log(msg) {
-    let div = document.getElementById("log");
-    div.innerHTML = div.innerHTML + "<p>" + msg + "</p>";
-  }
-
-  let audio = document.getElementById("tehaudio");
-  let button = document.getElementById("tehbutton");
-  let localaudio = document.getElementById("localaudio");
-
-  let pc1;
-  let pc2;
-
-  let pc1_offer;
-  let pc2_answer;
-
-  function failed(code) {
-    log("Failure callback: " + code);
-  }
-
-  // pc1.createOffer finished, call pc1.setLocal
-  function step1(offer) {
-    pc1_offer = offer;
-    pc1.setLocalDescription(offer, step2, failed);
-  }
-
-  // pc1.setLocal finished, call pc2.setRemote
-  function step2() {
-    pc2.setRemoteDescription(pc1_offer, step3, failed);
-  };
-
-  // pc2.setRemote finished, call pc2.createAnswer
-  function step3() {
-    pc2.createAnswer(pc1_offer, step4, failed);
-  }
-
-  // pc2.createAnswer finished, call pc2.setLocal
-  function step4(answer) {
-    pc2_answer = answer;
-    pc2.setLocalDescription(answer, step5, failed);
-  }
-
-  // pc2.setLocal finished, call pc1.setRemote
-  function step5() {
-    pc1.setRemoteDescription(pc2_answer, step6, failed);
-  }
-
-  // pc1.setRemote finished, media should be running!
-  function step6() {
-    log("HIP HIP HOORAY");
-  }
-
-  function start() {
-    button.innerHTML = "Stop!";
-    button.onclick = stop;
-
-    pc1 = new mozRTCPeerConnection();
-    pc2 = new mozRTCPeerConnection();
-
-    pc1.onaddstream = function(obj) {
-      log("pc1 got remote stream from pc2 " + obj.type);
-    }
-    pc2.onaddstream = function(obj) {
-      log("pc2 got remote stream from pc1 " + obj.type);
-      audio.src = obj.stream;
-      audio.play();
-    }
-
-    log("About to call getusermedia");
-
-    navigator.mozGetUserMedia({audio:true}, function(stream) {
-      // Add the stream obtained from gUM to an <audio> element to start
-      // the audio flow. We mute it on this end, and assign the "remote"
-      // stream when it arrives at pc2 to an unmuted <audio>.
-      localaudio.src = stream;
-      localaudio.play();
-
-      pc1.addStream(stream);
-      pc2.addStream(pc2.createFakeMediaStream("audio"));
-
-      // Start the signaling.
-      pc1.createOffer(step1, failed);
-    }, failed);
-  }
-
-  function stop() {
-    pc1.close();
-    pc2.close();
-
-    button.innerHTML = "Start!";
-    button.onclick = start;
-  }
-</script>
-
-</html>
diff --git a/dom/media/tests/local_data_chat.html b/dom/media/tests/local_data_chat.html
deleted file mode 100644
--- a/dom/media/tests/local_data_chat.html
+++ /dev/null
@@ -1,303 +0,0 @@
-<html>
-<head>
-  <title>Simple WebRTC Data Channel Test</title>
-</head>
-<body>
-
-<table width=100% height=100%>
-<tr><td><h1>Simple WebRTC Data Channel Test</h1></td></tr>
-<tr><td>(Note: this JS code is REALLY UGLY)</td></tr>
-<tr><td><div><button id="thebutton" onClick="start();">Start!</button></div><br/></td></tr>
-<tr><td><form id="pc1_form" action="javascript:sendit(1)">
-<div>pc1 says: <input id="pc1_input" type="text" value="type here" onKeyPress="return submitenter(this,event)"/>
-<input type="submit"/></div></form></td>
-<td><form id="pc1_blob" action="javascript:sendblob(1)">
-<div>pc1 sends a blob: <input id="pc1_browse" type="file"/>
-<input type="submit"/></div></form></td></tr>
-<tr><td><form id="pc2_form" action="javascript:sendit(2)">
-<div>pc2 says: <input id="pc2_input" type="text" value="type here" onKeyPress="return submitenter(this,event)"/>
-<input type="submit"/></div></form></td>
-<td><form id="pc2_blob" action="javascript:sendblob(2)">
-<div>pc2 sends a blob: <input id="pc2_browse" type="file"/>
-<input type="submit"/></div></form></td></tr>
-<tr><td><div id="datawindow" style="
-  width: 100%;
-  height: 500px;
-  overflow: auto;
-  border: 1px solid red;"></div></td></tr>
-
-<script type="application/javascript;version=1.8">
-  let button = document.getElementById("thebutton");
-  let text_pc1 = document.getElementById("pc1_input");
-  let text_pc2 = document.getElementById("pc2_input");
-  let blob_pc1 = document.getElementById("pc1_browse");
-  let blob_pc2 = document.getElementById("pc2_browse");
-  let datawindow = document.getElementById("datawindow");
-
-  let pc1;
-  let pc2;
-  let dc1;
-  let dc2;
-  let channel1;
-  let channel2;
-  let num_channels;
-  num_channels = 0;
-  var datachannels = new Array(0);
-
-  let pc1_offer;
-  let pc2_answer;
-  let iter = 0;
-  let iter2 = 0;
-
-  function log(msg) {
-    let div = document.getElementById("datawindow");
-    div.innerHTML = div.innerHTML + "<p>" + msg + "</p>";
-  }
-  var fancy_log = function(msg,color) {
-    var pre = document.createElement("p");
-    var message = '<span style="color: ' + color + ';">' + msg + '</span>';
-    pre.style.wordWrap = "break-word";
-    pre.innerHTML = message;
-    datawindow.appendChild(pre); // (window).* here doesn't work right
-
-    pre.scrollIntoView(false);
-  };
-
- function submitenter(myfield,e)
- {
-   var keycode;
-   if (window.event) keycode = window.event.keyCode;
-   else if (e) keycode = e.which;
-   else return true;
-
-   if (keycode == 13)
-   {
-     myfield.form.submit();
-     return false;
-   }
-   else
-     return true;
-  }
-
-  var sendit = function (which) {
-      iter = iter + 1;
-      //log("Sending message #" + iter + " this = " + this);
-      if (which == 1) {
-         dc1.send(text_pc1.value);
-         text_pc1.value = "";
-      } else if (which == 2) {
-         dc2.send(text_pc2.value);
-         text_pc2.value = "";
-      }
-      else log("Unknown send " + which);
-  };
-
-  var sendblob = function (which) {
-      iter = iter + 1;
-      //log("Sending blob #" + iter + " this = " + this);
-      if (which == 1) {
-         dc1.send(blob_pc1.files[0]);
-         blob_pc1.value = "";
-      } else if (which == 2) {
-         dc2.send(blob_pc2.files[0]);
-         blob_pc2.value = "";
-      }
-      else log("Unknown sendblob " + which);
-  };
-
-  function failed(code) {
-    log("Failure callback: " + code);
-  }
-
-  // pc1.createOffer finished, call pc1.setLocal
-  function step1(offer) {
-    pc1_offer = offer;
-    pc1.setLocalDescription(offer, step1_5, failed);
-  }
-
-  function step1_5() {
-    setTimeout(step2,0);
-  }
-  
-  // pc1.setLocal finished, call pc2.setRemote
-  function step2() {
-    pc2 = new mozRTCPeerConnection();
-
-    pc2.onDataChannel = function(channel) {
-      log("pc2 onDataChannel [" +num_channels + "] = " + channel +
-          ", label='" + channel.label + "'");
-      dc2 = channel;
-      datachannels[num_channels] = channel;
-      num_channels++;
-      log("pc2 created channel " + dc2 + " binarytype = " + dc2.binaryType);
-      channel.binaryType = "blob";
-      log("pc2 new binarytype = " + dc2.binaryType);
-
-      channel.onmessage = function(evt) {
-        iter2 = iter2 + 1;
-        if (evt.data instanceof Blob) {
-          fancy_log("*** pc1 sent Blob: " + evt.data + ", length=" + evt.data.size,"red");
-        } else {
-          fancy_log("*** pc1 said: " + evt.data + ", length=" + evt.data.length,"red");
-        }
-      };
-/*
-      channel.addEventListener("message",function(evt) {
-        fancy_log('*** pc1 said: ' + evt.data,"red");
-      }, false);
-*/
-      channel.onopen = function() {
-        log("*** pc2 onopen fired, sending to " + channel);
-  	channel.send("pc2 says Hi there!");
-      };
-      channel.onclose = function() {
-        log("*** pc2 onclose fired");
-      };
-      log("*** pc2 state:" + channel.readyState);
-      // There's a race condition with onopen; if the channel is already
-      // open it should fire after onDataChannel -- state should normally be 0 here
-      if (channel.readyState != 0) {
-        log("*** pc2 no onopen??! possible race");
-      }
-
-    };
-    pc2.onConnection = function() {
-      log("pc2 onConnection ");
-      //dc2 = pc2.createDataChannel();
-      //log("pc2 created channel " + dc2);
-    }
-    pc2.onClosedConnection = function() {
-      log("pc2 onClosedConnection ");
-    }
-
-    pc2.addStream(pc2.createFakeMediaStream("audio",true));
-    pc2.onaddstream = function(obj) {
-      log("pc2 got remote stream from pc1 " + obj.type);
-    }
-    pc2.setRemoteDescription(pc1_offer, step3, failed);
-  };
-
-  // pc2.setRemote finished, call pc2.createAnswer
-  function step3() {
-    pc2.createAnswer(pc1_offer, step4, failed);
-  }
-
-  // pc2.createAnswer finished, call pc2.setLocal
-  function step4(answer) {
-    pc2_answer = answer;
-    pc2.setLocalDescription(answer, step5, failed);
-  }
-
-  // pc2.setLocal finished, call pc1.setRemote
-  function step5() {
-    pc1.setRemoteDescription(pc2_answer, step6, failed);
-  }
-
-  // pc1.setRemote finished, make a data channel
-  function step6() {
-    log("HIP HIP HOORAY");
-    setTimeout(step7,2000);
-  }
-
-  function step7() {
-    pc1.connectDataConnection(5000,5001);
-    pc2.connectDataConnection(5001,5000);
-    log("connect for data channel called");
-  }
-
-function start() {
-    button.innerHTML = "Stop!";
-    button.onclick = stop;
-
-    pc1 = new mozRTCPeerConnection();
-
-    pc1.onaddstream = function(obj) {
-      log("pc1 got remote stream from pc2 " + obj.type);
-    }
-
-    pc1.onDataChannel = function(channel) {
-      // In case pc2 opens a channel
-      log("pc1 onDataChannel [" +num_channels + "] = " + channel +
-          ", label='" + channel.label + "'");
-      datachannels[num_channels] = channel;
-      num_channels++;
-
-      channel.onmessage = function(evt) {
-        if (evt.data instanceof Blob) {
-          fancy_log("*** pc2 sent Blob: " + evt.data + ", length=" + evt.data.size,"blue");
-        } else {
-          fancy_log('pc2 said: ' + evt.data + ", length=" + evt.data.length,"blue");
-        }
-      }
-/*
-      channel.addEventListener("message",function(evt) {
-        fancy_log('pc2 said: ' + evt.data,"blue");
-      }, false);
-*/
-      channel.onopen = function() {
-        log("pc1 onopen fired for " + channel);
-	channel.send("pc1 says Hello out there...");
-	log("pc1 state: " + channel.state);
-      }
-      channel.onclose = function() {
-        log("pc1 onclose fired");
-      };
-      log("pc1 state:" + channel.readyState);
-      // There's a race condition with onopen; if the channel is already
-      // open it should fire after onDataChannel -- state should normally be 0 here
-      if (channel.readyState != 0) {
-        log("*** pc1 no onopen??! possible race");
-      }
-    }
-    pc1.onConnection = function() {
-      log("pc1 onConnection ");
-      dc1 = pc1.createDataChannel("This is pc1",{}); // reliable (TCP-like)
-  //  dc1 = pc1.createDataChannel("This is pc1",{outOfOrderAllowed: true, maxRetransmitNum: 0}); // unreliable (UDP-like)
-      log("pc1 created channel " + dc1 + " binarytype = " + dc1.binaryType);
-      channel = dc1;
-      channel.binaryType = "blob";
-      log("pc1 new binarytype = " + dc1.binaryType);
-      
-
-      // Since we create the datachannel, don't wait for onDataChannel!
-      channel.onmessage = function(evt) {
-        if (evt.data instanceof Blob) {
-          fancy_log("*** pc2 sent Blob: " + evt.data + ", length=" + evt.data.size,"blue");
-        } else {
-          fancy_log('pc2 said: ' + evt.data,"blue");
-        }
-      }
-/*
-      // This is generally preferred to onxxx =
-      channel.addEventListener("message",function(evt) {
-        fancy_log('pc2 said: ' + evt.data,"blue");
-      }, false);
-*/
-      channel.onopen = function() {
-        log("pc1 onopen fired for " + channel);
-        channel.send("pc1 says Hello...");
-	       log("pc1 state: " + channel.state);
-      }
-      channel.onclose = function() {
-        log("pc1 onclose fired");
-      };
-      log("pc1 state:" + channel.readyState);
-    }
-    pc1.onClosedConnection = function() {
-      log("pc1 onClosedConnection ");
-    }
-
-    pc1.addStream(pc1.createFakeMediaStream("audio",true));
-    pc1.createOffer(step1, failed);
-  }
-
-  function stop() {
-    pc1.close();
-    pc2.close();
-
-    button.innerHTML = "Start!";
-    button.onclick = start;
-  }
-</script>
-
-</html>
diff --git a/dom/media/tests/local_data_test.html b/dom/media/tests/local_data_test.html
deleted file mode 100644
--- a/dom/media/tests/local_data_test.html
+++ /dev/null
@@ -1,88 +0,0 @@
- <html>
-<head>
-  <title>Simple WebRTC Data Channel Test</title>
-</head>
-<body>
-
-<h1>Simple WebRTC Data Channel Test</h1>
-<div><button id="tehbutton" onClick="start();">Start!</button></div><br/>
-<div id="log"></div>
-
-<script type="application/javascript;version=1.8">
-  function log(msg) {
-    let div = document.getElementById("log");
-    div.innerHTML = div.innerHTML + "<p>" + msg + "</p>";
-  }
-
-  let button = document.getElementById("tehbutton");
-
-  let pc1;
-  let pc2;
-
-  let pc1_offer;
-  let pc2_answer;
-
-  function failed(code) {
-    log("Failure callback: " + code);
-  }
-
-  // pc1.createOffer finished, call pc1.setLocal
-  function step1(offer) {
-    pc1_offer = offer;
-    pc1.setLocalDescription(offer, step2, failed);
-  }
-
-  // pc1.setLocal finished, call pc2.setRemote
-  function step2() {
-    pc2 = new mozRTCPeerConnection();
-    pc2.addStream(pc2.createFakeMediaStream("audio"));
-    pc2.onaddstream = function(obj) {
-      log("pc2 got remote stream from pc1 " + obj.type);
-    }
-    pc2.setRemoteDescription(pc1_offer, step3, failed);
-  };
-
-  // pc2.setRemote finished, call pc2.createAnswer
-  function step3() {
-    pc2.createAnswer(pc1_offer, step4, failed);
-  }
-
-  // pc2.createAnswer finished, call pc2.setLocal
-  function step4(answer) {
-    pc2_answer = answer;
-    pc2.setLocalDescription(answer, step5, failed);
-  }
-
-  // pc2.setLocal finished, call pc1.setRemote
-  function step5() {
-    pc1.setRemoteDescription(pc2_answer, step6, failed);
-  }
-
-  // pc1.setRemote finished, make a data channel
-  function step6() {
-    log("Creating a data channel: " + pc1.createDataChannel());
-  }
-
-  function start() {
-    button.innerHTML = "Stop!";
-    button.onclick = stop;
-
-    pc1 = new mozRTCPeerConnection();
-    pc1.onaddstream = function(obj) {
-      log("pc1 got remote stream from pc2 " + obj.type);
-    }
-
-    pc1.addStream(pc1.createFakeMediaStream("audio"));
-    pc1.createOffer(step1, failed);
-  }
-
-  function stop() {
-    pc1.close();
-    pc2.close();
-
-    button.innerHTML = "Start!";
-    button.onclick = start;
-  }
-</script>
-
-</html>
diff --git a/dom/media/tests/local_id_video.html b/dom/media/tests/local_id_video.html
deleted file mode 100644
--- a/dom/media/tests/local_id_video.html
+++ /dev/null
@@ -1,123 +0,0 @@
-<html>
-<head>
-  <title>Simple WebRTC-BrowserID Test</title>
-</head>
-<body>
-
-<h1>Simple WebRTC-BrowserID Test</h1>
-<div><h3>Remote video:</h3><video id="tehvideo" height="480" width="640" controls></video></div><br/>
-<div><button id="tehbutton" onClick="start();">Start!</button></div><br/>
-<div id="log"></div>
-<div><h3>Local video:</h3><video id="localvideo"></video></div><br/>
-
-<script type="application/javascript;version=1.8">
-  function log(msg) {
-    let div = document.getElementById("log");
-    div.innerHTML = div.innerHTML + "<p>" + msg + "</p>";
-  }
-
-  let video = document.getElementById("tehvideo");
-  let button = document.getElementById("tehbutton");
-  let localvideo = document.getElementById("localvideo");
-
-  let pc1;
-  let pc2;
-
-  let pc1_offer;
-  let pc2_answer;
-
-  function failed(code) {
-    log("Failure callback: " + code);
-  }
-
-  // pc1.createOffer finished, call pc1.setLocal
-  function step1(offer) {
-    pc1_offer = offer;
-    pc1.setLocalDescription(offer, step2, failed);
-  }
-
-  // pc1.setLocal finished, call pc2.setRemote
-  function step2() {
-    log("Got offer from pc1 <br/>" + pc1_offer);
-    pc2.setRemoteDescription(pc1_offer, step3, failed);
-  };
-
-  // pc2.setRemote finished, verify identity
-  function step3() {
-    pc2.verifyIdentity(pc1_offer, step4, failed);
-  }
-
-  // ID verified, call pc2.createAnswer
-  function step4(identity) {
-    alert(JSON.stringify(identity));
-    log("pc2 verified identity for <b>" + identity.principal.email + "</b>" +
-        " with fingerprint '" + identity.message + "'");
-    pc2.createAnswer(pc1_offer, step5, failed);
-  }
-
-  // pc2.createAnswer finished, call pc2.setLocal
-  function step5(answer) {
-    pc2_answer = answer;
-    pc2.setLocalDescription(answer, step6, failed);
-  }
-
-  // pc2.setLocal finished, call pc1.setRemote
-  function step6() {
-    log("Got answer from pc2 <br/>" + pc2_answer);
-    pc1.setRemoteDescription(pc2_answer, step7, failed);
-  }
-
-  // pc1.setRemote finished, media should be running!
-  function step7() {
-    log("HIP HIP HOORAY");
-  }
-
-  function start() {
-    button.innerHTML = "Stop!";
-    button.onclick = stop;
-
-    pc1 = new mozRTCPeerConnection();
-    pc1.onaddstream = function(obj) {
-      log("pc1 got remote stream from pc2 " + obj.type);
-    }
-
-    pc2 = new mozRTCPeerConnection();
-    pc2.onaddstream = function(obj) {
-      log("pc2 got remote stream from pc1 " + obj.type);
-      if (obj.type == "video") {
-        video.src = obj.stream;
-        video.play();
-      }
-    }
-
-    log("About to call getusermedia");
-    navigator.mozGetUserMedia({video:true}, function(stream) {
-      localvideo.src = stream;
-      localvideo.play();
-
-      pc1.addStream(stream);
-      pc1.addStream(pc1.createFakeMediaStream("audio"));
-
-      pc2.addStream(pc2.createFakeMediaStream("video"));
-      pc2.addStream(pc2.createFakeMediaStream("audio"));
-
-      // Select ID, then start the chain.
-      pc1.selectIdentity(function() {
-        log("pc1 selectIdentity finished successfully");
-        pc1.createOffer(step1, failed);
-      }, function(err) {
-        log("pc1 got error from selectIdentity: " + err);
-      });
-    }, failed);
-  }
-
-  function stop() {
-    pc1.close();
-    pc2.close();
-
-    button.innerHTML = "Start!";
-    button.onclick = start;
-  }
-</script>
-
-</html>
diff --git a/dom/media/tests/local_video_test.html b/dom/media/tests/local_video_test.html
deleted file mode 100644
--- a/dom/media/tests/local_video_test.html
+++ /dev/null
@@ -1,113 +0,0 @@
-<html>
-<head>
-  <title>Simple PeerConnection Video Test</title>
-</head>
-<body>
-
-<h1>Simple PeerConnection Video Test</h1>
-
-<div><video id="pc1video" width="640" height="480" controls></video></div><br/>
-<div><video id="pc2video" width="640" height="480" controls></video></div><br/>
-
-<div><button id="tehbutton" onClick="start();">Start!</button></div><br/>
-<div id="log"></div>
-
-<div><video id="localvideo" width="640" height="480" controls></video></div><br/>
-
-<script type="application/javascript;version=1.8">
-  function log(msg) {
-    let div = document.getElementById("log");
-    div.innerHTML = div.innerHTML + "<p>" + msg + "</p>";
-  }
-
-  let pc1video = document.getElementById("pc1video");
-  let pc2video = document.getElementById("pc2video");
-
-  let button = document.getElementById("tehbutton");
-  let localvideo = document.getElementById("localvideo");
-
-  let pc1;
-  let pc2;
-
-  let pc1_offer;
-  let pc2_answer;
-
-  function failed(code) {
-    log("Failure callback: " + code);
-  }
-
-  // pc1.createOffer finished, call pc1.setLocal
-  function step1(offer) {
-    pc1_offer = offer;
-    pc1.setLocalDescription(offer, step2, failed);
-  }
-
-  // pc1.setLocal finished, call pc2.setRemote
-  function step2() {
-    pc2.setRemoteDescription(pc1_offer, step3, failed);
-  };
-
-  // pc2.setRemote finished, call pc2.createAnswer
-  function step3() {
-    pc2.createAnswer(pc1_offer, step4, failed);
-  }
-
-  // pc2.createAnswer finished, call pc2.setLocal
-  function step4(answer) {
-    pc2_answer = answer;
-    pc2.setLocalDescription(answer, step5, failed);
-  }
-
-  // pc2.setLocal finished, call pc1.setRemote
-  function step5() {
-    pc1.setRemoteDescription(pc2_answer, step6, failed);
-  }
-
-  // pc1.setRemote finished, media should be running!
-  function step6() {
-    log("HIP HIP HOORAY");
-  }
-
-  function start() {
-    button.innerHTML = "Stop!";
-    button.onclick = stop;
-
-    pc1 = new mozRTCPeerConnection();
-    pc2 = new mozRTCPeerConnection();
-
-    pc1.onaddstream = function(obj) {
-      log("pc1 got remote stream from pc2 " + obj.type);
-      pc2video.src = obj.stream;
-      pc2video.play();
-    }
-    pc2.onaddstream = function(obj) {
-      log("pc2 got remote stream from pc1 " + obj.type);
-      pc1video.src = obj.stream;
-      pc1video.play();
-    }
-
-    navigator.mozGetUserMedia({video:true}, function(stream) {
-      // Add stream obtained from gUM to <video> to start media flow.
-      localvideo.src = stream;
-      localvideo.play();
-
-      pc1.addStream(stream);
-      pc1.addStream(pc1.createFakeMediaStream("audio"));
-      pc2.addStream(pc2.createFakeMediaStream("video"));
-      pc2.addStream(pc2.createFakeMediaStream("audio"));
-
-      // Start the signaling.
-      pc1.createOffer(step1, failed);
-    }, failed);
-  }
-
-  function stop() {
-    pc1.close();
-    pc2.close();
-
-    button.innerHTML = "Start!";
-    button.onclick = start;
-  }
-</script>
-
-</html>
diff --git a/dom/media/tests/raw_xpcshell_data.js b/dom/media/tests/raw_xpcshell_data.js
deleted file mode 100644
--- a/dom/media/tests/raw_xpcshell_data.js
+++ /dev/null
@@ -1,162 +0,0 @@
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-
-Components.utils.import("resource://gre/modules/Services.jsm");
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
-
-Cc["@mozilla.org/psm;1"].getService(Ci.nsISupports);
-
-let gScriptDone = false;
-
-let pc1 = Cc["@mozilla.org/peerconnection;1"]
-         .createInstance(Ci.IPeerConnection);
-let pc2 = Cc["@mozilla.org/peerconnection;1"]
-         .createInstance(Ci.IPeerConnection);
-
-let dc1;
-let dc2;
-
-let pc1_offer;
-let pc2_answer;
-
-let observer1 = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-  onCreateOfferError: function(code) {
-    print("pc1 onCreateOfferError " + code);
-  },
-  onSetLocalDescriptionError: function(code) {
-    print("pc1 onSetLocalDescriptionError " + code);
-  },
-  onSetRemoteDescriptionError: function(code) {
-    print("pc1 onSetRemoteDescriptionError " + code);
-  },
-  onStateChange: function(state) {
-    print("pc1 onStateChange " + state);
-  },
-  onAddStream: function(stream) {
-    print("pc1 onAddStream " + stream);
-  },
-  onDataChannel: function(channel) {
-    print("pc1 onDataChannel " + channel);
-    channel1 = channel;
-    channel.onopen = function() {
-        print("pc1 onopen fired");
-	channel1.send("Hello...");
-	print("pc1 state: " + channel.state);
-    };
-    print("pc1 state:" + channel.readyState);
-    // There's a race condition with onopen; if the channel is already open it should fire
-    if (channel.readyState != 0)
-	channel1.send("Hello...");
-    channel.onmessage = function(evt) {
-        print('pc1 RESPONSE: ' + evt.data  + "state = " + channel.readyState);
-    };
-  },
-  onConnection: function() {
-    print("pc1 onConnection ");
-    dc1 = pc1.createDataChannel();
-  },
-  onClosedConnection: function() {
-    print("pc1 onClosedConnection ");
-  },
-};
-
-let observer2 = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-  onCreateAnswerError: function(code) {
-    print("pc2 onCreateAnswerError " + code);
-  },
-  onSetLocalDescriptionError: function(code) {
-    print("pc2 onSetLocalDescriptionError " + code);
-  },
-  onSetRemoteDescriptionError: function(code) {
-    print("pc2 onSetRemoteDescriptionError " + code);
-  },
-  onStateChange: function(state) {
-    print("pc2 onStateChange " + state);
-  },
-  onAddStream: function(stream) {
-    print("pc2 onAddStream " + stream);
-  },
-  onDataChannel: function(channel) {
-    print("pc2 onDataChannel " + channel);
-    channel2 = channel;
-    channel.onopen = function() {
-        print("pc2 onopen fired");
-	channel2.send("Hi there!");
-    };
-    print("pc2 state:" + channel.readyState);
-    // There's a race condition with onopen; if the channel is already open it should fire
-    if (channel.readyState != 0)
-	channel2.send("Hi there!");	
-    channel.onmessage = function(evt) {
-        print('pc2 RESPONSE: ' + evt.data  + "state = " + channel.readyState);
-    };
-  },
-  onConnection: function() {
-    print("pc2 onConnection ");
-    dc2 = pc2.createDataChannel();
-  },
-  onClosedConnection: function() {
-    print("pc2 onClosedConnection ");
-  },
-};
-
-// pc1.createOffer -> pc1.setLocal
-observer1.onCreateOfferSuccess = function(offer) {
-  print("pc1 got offer: \n" + offer);
-  pc1.setLocalDescription(Ci.IPeerConnection.kActionOffer, offer);
-  pc1_offer = offer;
-};
-
-// pc1.setLocal -> pc2.setRemote
-observer1.onSetLocalDescriptionSuccess = function(code) {
-  print("pc1 onSetLocalDescriptionSuccess: " + code);
-  pc2.setRemoteDescription(Ci.IPeerConnection.kActionOffer, pc1_offer);
-};
-
-// pc2.setRemote -> pc2.createAnswer
-observer2.onSetRemoteDescriptionSuccess = function(code) {
-  print("pc2 onSetRemoteDescriptionSuccess: " + code);
-  pc2.createAnswer("", pc1_offer);
-};
-
-// pc2.createAnswer -> pc2.setLocal
-observer2.onCreateAnswerSuccess = function(answer) {
-  print("pc2 got answer: \n" + answer);
-  pc2.setLocalDescription(Ci.IPeerConnection.kActionAnswer, answer);
-  pc2_answer = answer;
-};
-
-// pc2.setLocal -> pc1.setRemote
-observer2.onSetLocalDescriptionSuccess = function(code) {
-  print("pc2 onSetLocalDescriptionSuccess: " + code);
-  pc1.setRemoteDescription(Ci.IPeerConnection.kActionAnswer, pc2_answer);
-};
-
-// pc1.setRemote -> finish!
-observer1.onSetRemoteDescriptionSuccess = function(code) {
-  print("pc1 onSetRemoteDescriptionSuccess: " + code);
-  // run traffic for 5 seconds, then terminate
-  let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-  timer.initWithCallback(function() {
-    gScriptDone = true;
-  }, 5000, Ci.nsITimer.TYPE_ONE_SHOT);
-};
-
-let mainThread = Services.tm.currentThread;
-pc1.initialize(observer1, null, mainThread);
-pc2.initialize(observer2, null, mainThread);
-
-pc1.listen(6747);
-pc2.connect("127.0.0.1",6747);
-
-let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-timer.initWithCallback(function() {
-  gScriptDone = true;
-}, 10000, Ci.nsITimer.TYPE_ONE_SHOT);
-
-while (!gScriptDone)
-  mainThread.processNextEvent(true);
-while (mainThread.hasPendingEvents())
-  mainThread.processNextEvent(true);
diff --git a/dom/media/tests/raw_xpcshell_video.js b/dom/media/tests/raw_xpcshell_video.js
deleted file mode 100644
--- a/dom/media/tests/raw_xpcshell_video.js
+++ /dev/null
@@ -1,121 +0,0 @@
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-
-Components.utils.import("resource://gre/modules/Services.jsm");
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
-
-Cc["@mozilla.org/psm;1"].getService(Ci.nsISupports);
-
-let gScriptDone = false;
-
-let pc1 = Cc["@mozilla.org/peerconnection;1"]
-         .createInstance(Ci.IPeerConnection);
-let pc2 = Cc["@mozilla.org/peerconnection;1"]
-         .createInstance(Ci.IPeerConnection);
-
-let pc1_offer;
-let pc2_answer;
-
-let observer1 = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-  onCreateOfferError: function(code) {
-    print("pc1 onCreateOfferError " + code);
-  },
-  onSetLocalDescriptionError: function(code) {
-    print("pc1 onSetLocalDescriptionError " + code);
-  },
-  onSetRemoteDescriptionError: function(code) {
-    print("pc1 onSetRemoteDescriptionError " + code);
-  },
-  onStateChange: function(state) {
-    print("pc1 onStateChange " + state);
-  },
-  onAddStream: function(stream) {
-    print("pc1 onAddStream " + stream);
-  }
-};
-
-let observer2 = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-  onCreateAnswerError: function(code) {
-    print("pc2 onCreateAnswerError " + code);
-  },
-  onSetLocalDescriptionError: function(code) {
-    print("pc2 onSetLocalDescriptionError " + code);
-  },
-  onSetRemoteDescriptionError: function(code) {
-    print("pc2 onSetRemoteDescriptionError " + code);
-  },
-  onStateChange: function(state) {
-    print("pc2 onStateChange " + state);
-  },
-  onAddStream: function(stream) {
-    print("pc2 onAddStream " + stream);
-  }
-};
-
-// pc1.createOffer -> pc1.setLocal
-observer1.onCreateOfferSuccess = function(offer) {
-  print("pc1 got offer: \n" + offer);
-  pc1.setLocalDescription(Ci.IPeerConnection.kActionOffer, offer);
-  pc1_offer = offer;
-};
-
-// pc1.setLocal -> pc2.setRemote
-observer1.onSetLocalDescriptionSuccess = function(code) {
-  print("pc1 onSetLocalDescriptionSuccess: " + code);
-  pc2.setRemoteDescription(Ci.IPeerConnection.kActionOffer, pc1_offer);
-};
-
-// pc2.setRemote -> pc2.createAnswer
-observer2.onSetRemoteDescriptionSuccess = function(code) {
-  print("pc2 onSetRemoteDescriptionSuccess: " + code);
-  pc2.createAnswer("", pc1_offer);
-};
-
-// pc2.createAnswer -> pc2.setLocal
-observer2.onCreateAnswerSuccess = function(answer) {
-  print("pc2 got answer: \n" + answer);
-  pc2.setLocalDescription(Ci.IPeerConnection.kActionAnswer, answer);
-  pc2_answer = answer;
-};
-
-// pc2.setLocal -> pc1.setRemote
-observer2.onSetLocalDescriptionSuccess = function(code) {
-  print("pc2 onSetLocalDescriptionSuccess: " + code);
-  pc1.setRemoteDescription(Ci.IPeerConnection.kActionAnswer, pc2_answer);
-};
-
-// pc1.setRemote -> finish!
-observer1.onSetRemoteDescriptionSuccess = function(code) {
-  print("pc1 onSetRemoteDescriptionSuccess: " + code);
-  // run traffic for 5 seconds, then terminate
-  let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-  timer.initWithCallback(function() {
-    gScriptDone = true;
-  }, 5000, Ci.nsITimer.TYPE_ONE_SHOT);
-};
-
-let mainThread = Services.tm.currentThread;
-pc1.initialize(observer1, mainThread);
-pc2.initialize(observer2, mainThread);
-
-let stream1v = pc1.createFakeMediaStream(Ci.IPeerConnection.kHintVideo);
-pc1.addStream(stream1v);
-
-let stream1a = pc1.createFakeMediaStream(Ci.IPeerConnection.kHintAudio | 0x80);
-pc1.addStream(stream1a);
-
-let stream2v = pc2.createFakeMediaStream(Ci.IPeerConnection.kHintVideo);
-pc2.addStream(stream2v);
-
-let stream2a = pc2.createFakeMediaStream(Ci.IPeerConnection.kHintAudio | 0x80);
-pc2.addStream(stream2a);
-
-// start the chain.
-pc1.createOffer("");
-
-while (!gScriptDone)
-  mainThread.processNextEvent(true);
-while (mainThread.hasPendingEvents())
-  mainThread.processNextEvent(true);
diff --git a/dom/media/tests/unit/test_pc_answer.js b/dom/media/tests/unit/test_pc_answer.js
deleted file mode 100644
--- a/dom/media/tests/unit/test_pc_answer.js
+++ /dev/null
@@ -1,91 +0,0 @@
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-function run_test() {
-  // Load PSM (initializes NSS)
-  Cc["@mozilla.org/psm;1"].getService(Ci.nsISupports);
-  run_next_test();
-}
-
-add_test(function createOfferAnswer() {
-  let pc1 = Cc["@mozilla.org/peerconnection;1"]
-           .createInstance(Ci.IPeerConnection);
-  let pc2 = Cc["@mozilla.org/peerconnection;1"]
-           .createInstance(Ci.IPeerConnection);
-
-  let pc1_offer;
-  let pc2_answer;
-
-  let observer1 = {
-    QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-    onCreateOfferError: function(code) {},
-    onSetLocalDescriptionError: function(code) {},
-    onSetRemoteDescriptionError: function(code) {},
-    onStateChange: function(state) {},
-    onAddStream: function(stream) {}
-  };
-
-  let observer2 = {
-    QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-    onCreateAnswerError: function(code) {},
-    onSetLocalDescriptionError: function(code) {},
-    onSetRemoteDescriptionError: function(code) {},
-    onStateChange: function(state) {},
-    onAddStream: function(stream) {}
-  };
-
-  // pc1.createOffer -> pc1.setLocal
-  observer1.onCreateOfferSuccess = function(offer) {
-    do_print("pc1 got offer: \n" + offer);
-    pc1.setLocalDescription(Ci.IPeerConnection.kActionOffer, offer);
-    pc1_offer = offer;
-  };
-
-  // pc1.setLocal -> pc2.setRemote
-  observer1.onSetLocalDescriptionSuccess = function(code) {
-    do_print("pc1 onSetLocalDescriptionSuccess: " + code);
-    pc2.setRemoteDescription(Ci.IPeerConnection.kActionOffer, pc1_offer);
-  };
-
-  // pc2.setRemote -> pc2.createAnswer
-  observer2.onSetRemoteDescriptionSuccess = function(code) {
-    do_print("pc2 onSetRemoteDescriptionSuccess: " + code);
-    pc2.createAnswer("", pc1_offer);
-  };
-
-  // pc2.createAnswer -> pc2.setLocal
-  observer2.onCreateAnswerSuccess = function(answer) {
-    do_print("pc2 got answer: \n" + answer);
-    pc2.setLocalDescription(Ci.IPeerConnection.kActionAnswer, answer);
-    pc2_answer = answer;
-  };
-
-  // pc2.setLocal -> pc1.setRemote
-  observer2.onSetLocalDescriptionSuccess = function(code) {
-    do_print("pc2 onSetLocalDescriptionSuccess: " + code);
-    pc1.setRemoteDescription(Ci.IPeerConnection.kActionAnswer, pc2_answer);
-  };
-
-  // pc1.setRemote -> finish!
-  observer1.onSetRemoteDescriptionSuccess = function(code) {
-    do_print("pc1 onSetRemoteDescriptionSuccess: " + code);
-    // run traffic for 5 seconds, then terminate.
-    let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-    timer.initWithCallback(function() {
-      run_next_test();
-    }, 5000, Ci.nsITimer.TYPE_ONE_SHOT);
-  };
-
-  let mainThread = Services.tm.currentThread;
-  pc1.initialize(observer1, mainThread);
-  pc2.initialize(observer2, mainThread);
-
-  let stream1 = pc1.createFakeMediaStream(Ci.IPeerConnection.kHintAudio);
-  pc1.addStream(stream1);
-
-  let stream2 = pc2.createFakeMediaStream(Ci.IPeerConnection.kHintAudio);
-  pc2.addStream(stream2);
-
-  // start the chain.
-  pc1.createOffer("");
-});
diff --git a/dom/media/tests/unit/test_pc_offer.js b/dom/media/tests/unit/test_pc_offer.js
deleted file mode 100644
--- a/dom/media/tests/unit/test_pc_offer.js
+++ /dev/null
@@ -1,49 +0,0 @@
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-function run_test() {
-  // Load PSM (initializes NSS)
-  Cc["@mozilla.org/psm;1"].getService(Ci.nsISupports);
-  run_next_test();
-}
-
-add_test(function createComponent() {
-  try {
-    let component = Cc["@mozilla.org/peerconnection;1"]
-                    .createInstance(Ci.IPeerConnection);
-  } catch(e) {
-    // Failed to create the component.
-    do_check_true(false);
-  }
-  run_next_test();
-});
-
-add_test(function createOffer() {
-  let pc = Cc["@mozilla.org/peerconnection;1"]
-           .createInstance(Ci.IPeerConnection);
-  do_check_eq(typeof pc.createOffer, "function");
-
-  let observer = {
-    QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
-    onCreateOfferSuccess: function(offer) {
-      do_check_neq(offer, false);
-      pc.setLocalDescription(0, offer);
-    },
-    onCreateOfferError: function(code) {
-      do_check_true(false);
-      run_next_test();
-    },
-    onSetLocalDescriptionSuccess: function(code) {
-      run_next_test();
-    },
-    onSetLocalDescriptionError: function(code) {
-      do_check_true(false);
-      run_next_test();
-    }
-  };
-
-  pc.initialize(observer, Services.tm.currentThread);
-  let stream = pc.createFakeMediaStream(Ci.IPeerConnection.kHintAudio);
-  pc.addStream(stream);
-  pc.createOffer("");
-});
diff --git a/dom/media/tests/unit/xpcshell.ini b/dom/media/tests/unit/xpcshell.ini
deleted file mode 100644
--- a/dom/media/tests/unit/xpcshell.ini
+++ /dev/null
@@ -1,7 +0,0 @@
-[DEFAULT]
-head = ../../../../services/common/tests/unit/head_global.js ../../../../services/common/tests/unit/head_helpers.js
-tail =
-fail-if = true
-
-[test_pc_offer.js]
-[test_pc_answer.js]
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
@@ -161,25 +161,25 @@ public:
             default:
               CSFLogDebugS(logTag, ": **** CALL STATE IS: " << statestr);
               break;
           }
           break;
         }
       case PC_OBSERVER_CONNECTION:
         CSFLogDebugS(logTag, __FUNCTION__ << ": Delivering PeerConnection onconnection");
-        mObserver->NotifyConnection();
+        //mObserver->NotifyConnection();
         break;
       case PC_OBSERVER_CLOSEDCONNECTION:
         CSFLogDebugS(logTag, __FUNCTION__ << ": Delivering PeerConnection onclosedconnection");
-        mObserver->NotifyClosedConnection();
+        //mObserver->NotifyClosedConnection();
         break;
       case PC_OBSERVER_DATACHANNEL:
         CSFLogDebugS(logTag, __FUNCTION__ << ": Delivering PeerConnection ondatachannel");
-        mObserver->NotifyDataChannel(mChannel);
+        //mObserver->NotifyDataChannel(mChannel);
 #ifdef MOZILLA_INTERNAL_API
         NS_DataChannelAppReady(mChannel);
 #endif
         break;
       case PC_OBSERVER_ICE:
         CSFLogDebugS(logTag, __FUNCTION__ << ": Delivering PeerConnection ICE callback ");
         mObserver->OnStateChange(IPeerConnectionObserver::kIceState);
     }
@@ -493,17 +493,17 @@ PeerConnectionImpl::Initialize(IPeerConn
   while(PeerConnectionCtx::GetInstance()->sipcc_state() != kStarted) {
     PR_Sleep(100);
   }
 #endif
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 PeerConnectionImpl::CreateFakeMediaStream(PRUint32 hint, nsIDOMMediaStream** retval)
 {
   MOZ_ASSERT(retval);
 
   bool mute = false;
 
   // Hack to allow you to mute the stream
   if (hint & 0x80) {
@@ -532,16 +532,17 @@ PeerConnectionImpl::CreateFakeMediaStrea
       new Fake_VideoGenerator(static_cast<nsDOMMediaStream*>(*retval));
 #endif
     }
   }
 
   return NS_OK;
 }
 
+/*
 NS_IMETHODIMP
 PeerConnectionImpl::ConnectDataConnection(PRUint16 localport, PRUint16 remoteport, PRUint16 numstreams)
 {
 #ifdef MOZILLA_INTERNAL_API
     mDataConnection = new mozilla::DataChannelConnection(this);
     NS_ENSURE_TRUE(mDataConnection,NS_ERROR_FAILURE);
     mDataConnection->Init(localport, numstreams, true);
     // XXX errors?
@@ -582,17 +583,17 @@ PeerConnectionImpl::CreateDataChannel(co
       (type == mozilla::DataChannelConnection::PARTIAL_RELIABLE_TIMED ? maxTime : 0),
                                        NULL, NULL);
   if (!aDataChannel)
     return NS_ERROR_FAILURE;
 
   CSFLogDebugS(logTag, __FUNCTION__ << ": making DOMDataChannel");
 
   return NS_NewDOMDataChannel(aDataChannel,
-                              mWindow, /* GetOwner(), */
+                              mWindow, GetOwner(),
                               aRetval);
 #else
   return NS_OK;
 #endif
 }
 
 
 NS_IMETHODIMP
@@ -722,32 +723,33 @@ void
 PeerConnectionImpl::NotifyDataChannel(mozilla::DataChannel *channel)
 {
   MOZ_ASSERT(channel);
 
   CSFLogDebugS(logTag, __FUNCTION__ << ": channel: " << static_cast<void*>(channel));
 
 #ifdef MOZILLA_INTERNAL_API
   nsCOMPtr<nsIDOMDataChannel> domchannel;
-  nsresult rv = NS_NewDOMDataChannel(channel, mWindow /*GetOwner()*/,
+  nsresult rv = NS_NewDOMDataChannel(channel, mWindow GetOwner(),
                                      getter_AddRefs(domchannel));
-  NS_ENSURE_SUCCESS(rv, /**/);
+  NS_ENSURE_SUCCESS(rv, );
 
   if (mPCObserver) {
     PeerConnectionObserverDispatch* runnable =
       new PeerConnectionObserverDispatch(PC_OBSERVER_DATACHANNEL, domchannel.get(),
                                          this, mPCObserver);
     if (mThread) {
       mThread->Dispatch(runnable, NS_DISPATCH_NORMAL);
       return;
     }
     runnable->Run();
   }
 #endif
 }
+*/
 
 /*
  * CC_SDP_DIRECTION_SENDRECV will not be used when Constraints are implemented
  */
 NS_IMETHODIMP
 PeerConnectionImpl::CreateOffer(const char* hints) {
   MOZ_ASSERT(hints);
 
@@ -893,16 +895,17 @@ PeerConnectionImpl::CloseStreams() {
   if (mReadyState != PeerConnectionImpl::kClosed)  {
     ChangeReadyState(PeerConnectionImpl::kClosing);
   }
 
   mCall->endCall();
   return NS_OK;
 }
 
+/*
 NS_IMETHODIMP
 PeerConnectionImpl::SetRemoteFingerprint(const char* hash, const char* fingerprint)
 {
   MOZ_ASSERT(hash);
   MOZ_ASSERT(fingerprint);
 
   if (fingerprint != NULL && (strcmp(hash, "sha-1") == 0)) {
     mRemoteFingerprint = std::string(fingerprint);
@@ -924,16 +927,17 @@ PeerConnectionImpl::GetFingerprint(char*
 
   char* tmp = new char[mFingerprint.size() + 1];
   std::copy(mFingerprint.begin(), mFingerprint.end(), tmp);
   tmp[mFingerprint.size()] = '\0';
 
   *fingerprint = tmp;
   return NS_OK;
 }
+*/
 
 NS_IMETHODIMP
 PeerConnectionImpl::GetLocalDescription(char** sdp)
 {
   MOZ_ASSERT(sdp);
 
   char* tmp = new char[mLocalSDP.size() + 1];
   std::copy(mLocalSDP.begin(), mLocalSDP.end(), tmp);
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
@@ -293,19 +293,19 @@ public:
   // Implementation of the only observer we need
   virtual void onCallEvent(
     ccapi_call_event_e callEvent,
     CSF::CC_CallPtr call,
     CSF::CC_CallInfoPtr info
   );
 
   // DataConnection observers
-  void NotifyConnection();
-  void NotifyClosedConnection();
-  void NotifyDataChannel(mozilla::DataChannel *channel);
+  //void NotifyConnection();
+  //void NotifyClosedConnection();
+  //void NotifyDataChannel(mozilla::DataChannel *channel);
 
   // Handle system to allow weak references to be passed through C code
   static PeerConnectionWrapper *AcquireInstance(const std::string& handle);
   virtual void ReleaseInstance();
   virtual const std::string& GetHandle();
 
   // ICE events
   void IceGatheringCompleted(NrIceCtx *ctx);
@@ -355,16 +355,19 @@ public:
   nsCOMPtr<nsIThread> GetMainThread() { return mThread; }
 
   // Get the STS thread
   nsCOMPtr<nsIEventTarget> GetSTSThread() { return mSTSThread; }
 
   // Get the DTLS identity
   mozilla::RefPtr<DtlsIdentity> const GetIdentity() { return mIdentity; }
 
+  // Create a fake media stream
+  nsresult CreateFakeMediaStream(PRUint32 hint, nsIDOMMediaStream** retval);
+
 private:
   PeerConnectionImpl(const PeerConnectionImpl&rhs);
   PeerConnectionImpl& operator=(PeerConnectionImpl);
 
   void ChangeReadyState(ReadyState ready_state);
   void CheckApiState() {
     PR_ASSERT(mIceState != kIceGathering);
   }
diff --git a/media/webrtc/signaling/test/signaling_unittests.cpp b/media/webrtc/signaling/test/signaling_unittests.cpp
--- a/media/webrtc/signaling/test/signaling_unittests.cpp
+++ b/media/webrtc/signaling/test/signaling_unittests.cpp
@@ -177,17 +177,17 @@ TestObserver::OnSetLocalDescriptionError
 
 NS_IMETHODIMP
 TestObserver::OnSetRemoteDescriptionError(PRUint32 code)
 {
   state = stateError;
   lastStatusCode = code;
   return NS_OK;
 }
-
+/*
 NS_IMETHODIMP
 TestObserver::NotifyConnection()
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 TestObserver::NotifyClosedConnection()
@@ -195,16 +195,17 @@ TestObserver::NotifyClosedConnection()
   return NS_OK;
 }
 
 NS_IMETHODIMP
 TestObserver::NotifyDataChannel(nsIDOMDataChannel *channel)
 {
   return NS_OK;
 }
+*/
 
 NS_IMETHODIMP
 TestObserver::OnStateChange(PRUint32 state_type)
 {
   nsresult rv;
   PRUint32 gotstate;
 
   switch (state_type)
diff --git a/netwerk/sctp/datachannel/DataChannel.h b/netwerk/sctp/datachannel/DataChannel.h
--- a/netwerk/sctp/datachannel/DataChannel.h
+++ b/netwerk/sctp/datachannel/DataChannel.h
@@ -78,23 +78,23 @@ public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSITIMERCALLBACK
 
   class DataConnectionListener {
   public:
     virtual ~DataConnectionListener() {}
 
     // Called when a the connection is open
-    virtual void NotifyConnection() = 0;
+    //virtual void NotifyConnection() = 0;
 
     // Called when a the connection is lost/closed
-    virtual void NotifyClosedConnection() = 0;
+    //virtual void NotifyClosedConnection() = 0;
 
     // Called when a new DataChannel has been opened by the other side.
-    virtual void NotifyDataChannel(DataChannel *channel) = 0;
+    //virtual void NotifyDataChannel(DataChannel *channel) = 0;
   };
 
   DataChannelConnection(DataConnectionListener *listener);
   virtual ~DataChannelConnection();
 
   bool Init(unsigned short aPort, uint16_t aNumStreams, bool aUsingDtls);
 
   // These block; they require something to decide on listener/connector
@@ -426,23 +426,23 @@ public:
         break;
       case ON_CHANNEL_OPEN:
         mChannel->mListener->OnChannelConnected(mChannel->mContext);
         break;
       case ON_CHANNEL_CLOSED:
         mChannel->mListener->OnChannelClosed(mChannel->mContext);
         break;
       case ON_CHANNEL_CREATED:
-        mConnection->mListener->NotifyDataChannel(mChannel);
+        //mConnection->mListener->NotifyDataChannel(mChannel);
         break;
       case ON_CONNECTION:
-        mConnection->mListener->NotifyConnection();
+        //mConnection->mListener->NotifyConnection();
         break;
       case ON_DISCONNECTED:
-        mConnection->mListener->NotifyClosedConnection();
+        //mConnection->mListener->NotifyClosedConnection();
         break;
       case START_DEFER:
         mConnection->StartDefer();
         break;
     }
     return NS_OK;
   }
 
