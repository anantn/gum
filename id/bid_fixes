# HG changeset patch
# Parent 0201d1ce7b7585b22977ab9568e0d377b2c9a15a

diff --git a/browser/modules/SignInToWebsite.jsm b/browser/modules/SignInToWebsite.jsm
--- a/browser/modules/SignInToWebsite.jsm
+++ b/browser/modules/SignInToWebsite.jsm
@@ -64,17 +64,17 @@ let SignInToWebsiteUX = {
         break;
     }
   },
 
   /**
    * The website is requesting login so the user must choose an identity to use.
    */
   requestLogin: function SignInToWebsiteUX_requestLogin(aOptions) {
-    let windowID = aOptions.rpId;
+    let windowID = aOptions.windowId;
     log("requestLogin", aOptions);
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     // message is not shown in the UI but is required
     let message = aOptions.origin;
     let mainAction = {
       label: chromeWin.gNavigatorBundle.getString("identity.next.label"),
       accessKey: chromeWin.gNavigatorBundle.getString("identity.next.accessKey"),
@@ -170,17 +170,17 @@ let SignInToWebsiteUX = {
     else
       Logger.reportError("SignInToWebsite", "Could not close window with ID", aAuthId);
   },
 
   /**
    * Show a doorhanger indicating the currently logged-in user.
    */
   _showLoggedInUI: function _showLoggedInUI(aIdentity, aContext) {
-    let windowID = aContext.rpId;
+    let windowID = aContext.windowId;
     log("_showLoggedInUI for ", windowID);
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     let message = chromeWin.gNavigatorBundle.getFormattedString("identity.loggedIn.description",
                                                           [aIdentity]);
     let mainAction = {
       label: chromeWin.gNavigatorBundle.getString("identity.loggedIn.signOut.label"),
       accessKey: chromeWin.gNavigatorBundle.getString("identity.loggedIn.signOut.accessKey"),
@@ -191,39 +191,39 @@ let SignInToWebsiteUX = {
     };
     let secondaryActions = [];
     let options = {
       dismissed: true,
     };
     let loggedInNot = chromeWin.PopupNotifications.show(browserEl, "identity-logged-in", message,
                                                   "identity-notification-icon", mainAction,
                                                   secondaryActions, options);
-    loggedInNot.rpId = windowID;
+    loggedInNot.rpId = aContext.rpId;
   },
 
   /**
    * Remove the doorhanger indicating the currently logged-in user.
    */
   _removeLoggedInUI: function _removeLoggedInUI(aContext) {
-    let windowID = aContext.rpId;
+    let windowID = aContext.windowId;
     log("_removeLoggedInUI for ", windowID);
     if (!windowID)
       throw "_removeLoggedInUI: Invalid RP ID";
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     let loggedInNot = chromeWin.PopupNotifications.getNotification("identity-logged-in", browserEl);
     if (loggedInNot)
       chromeWin.PopupNotifications.remove(loggedInNot);
   },
 
   /**
    * Remove the doorhanger indicating the currently logged-in user.
    */
   _removeRequestUI: function _removeRequestUI(aContext) {
-    let windowID = aContext.rpId;
+    let windowID = aContext.windowId;
     log("_removeRequestUI for ", windowID);
     let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
 
     let requestNot = chromeWin.PopupNotifications.getNotification("identity-request", browserEl);
     if (requestNot)
       chromeWin.PopupNotifications.remove(requestNot);
   },
 
diff --git a/toolkit/identity/Identity.jsm b/toolkit/identity/Identity.jsm
--- a/toolkit/identity/Identity.jsm
+++ b/toolkit/identity/Identity.jsm
@@ -311,17 +311,17 @@ IDService.prototype = {
         // Yay.  Valid IdP configuration for the domain.
         return aCallback(null, callbackObj);
 
       } catch (err) {
         reportError("_fetchWellKnownFile", "Bad configuration from", aDomain, err);
         return aCallback(err.toString());
       }
     };
-    req.onerror = function _fetchWellKnownFile_onerror() {
+    req.onerror = function _fetchWellKnownFile_onerror(err) {
       log("_fetchWellKnownFile", "ERROR:", req.status, req.statusText);
       log("ERROR: _fetchWellKnownFile:", err);
       return aCallback("Error");
     };
     req.send(null);
   },
 
 };
diff --git a/toolkit/identity/WebRTC.jsm b/toolkit/identity/WebRTC.jsm
--- a/toolkit/identity/WebRTC.jsm
+++ b/toolkit/identity/WebRTC.jsm
@@ -1,22 +1,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-const EXPORTED_SYMBOLS = ["selectIdentity"];
+const EXPORTED_SYMBOLS = ["selectIdentity", "verifyIdentity"];
 const DEFAULT_IDP = "browserid.org";
 const DEFAULT_PROTOCOL = "persona";
 
 const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/identity/jwcrypto.jsm");
 Cu.import("resource://gre/modules/identity/Identity.jsm");
 Cu.import("resource://gre/modules/identity/RelyingParty.jsm");
 
 Cu.import("resource://services-common/utils.js");
 
 function AuthModule(aPeerConnectionId, aIdentity) {
   // XXX: How do we know aIDP.idp aIDP.origin are valid?
   this.peerConnectionId = aPeerConnectionId;
@@ -30,18 +31,58 @@ AuthModule.prototype = {
   sign: function(aOrigin, aMessage, aCallback) {
     // XXX need to deal with the case where the cert has expired between
     // selectIdentity and now
     RelyingParty._generateAssertion(
       aOrigin, this.identity, {message:aMessage}, aCallback
     );
   },
   verify: function(aAssertion, aCallback) {
+    // XXX: Use verifyIdentity for now until we get real crypto verification
+  }
+};
 
+/**
+ * Verify an identity based on a signature provided by a WEBRTC PeerConnection
+ *
+ * @param aSignature        The signature provided by the remote peer.
+ *        (string)
+ *
+ * @param aCallback         Called after the signature has been verified. First
+ *        (function)        argument will be a string error (if any) or null.
+ *                          If no error, second argument will be a dictionary
+ *                          describing the verified identity (such as the one
+ *                          provided by selectIdentity).
+ */
+let verifyIdentity = function verifyIdentity(aSignature, aCallback) {
+  let parts = aSignature.split(".");
+  if (parts.length != 5) {
+    aCallback(new Error("Invalid signature"), null);
+    return;
   }
+
+  let pubkey = "blah";
+  let message = JSON.parse(jwcrypto.base64Decode(parts[3]));
+  let assertion = [parts[0], parts[1], parts[2]].join(".");
+
+  jwcrypto.verifyAssertion(assertion, pubkey, function(err, val) {
+    if (err) {
+      aCallback(err, null);
+      return;
+    }
+    let ret = {
+      aud: message.aud,
+      message: message.message,
+      iss: val.iss,
+      exp: val.exp,
+      iat: val.iat,
+      principal: val.principal
+    };
+    aCallback(null, ret);
+  });
 };
 
 /**
  * Select an identity for use by a WEBRTC PeerConnection
  *
  * @param aPeerConnectionId
  *        (string)          The unique ID of the PeerConnection.  Something
  *                          like a uuid would be lovely.
