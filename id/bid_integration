# HG changeset patch
# Parent 2570ab2ce58c11270dea131195faf6ea09b7b21a

diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -1,38 +1,40 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+const IDService = {};
 const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/identity/WebRTC.jsm", IDService);
 
 const PC_CONTRACT = "@mozilla.org/dom/peerconnection;1";
 const PC_CID = Components.ID("{7cb2b368-b1ce-4560-acac-8e0dbda7d3d0}");
 
-function PeerConnection() {
-  this._pc = Cc["@mozilla.org/peerconnection;1"].
-             createInstance(Ci.IPeerConnection);
-  this._observer = new PeerConnectionObserver(this);
-
-  dump("!!! mozPeerConnection constructor called " + this._pc + "\n\n");
-  this._pc.initialize(this._observer, Services.tm.currentThread);
-}
+function PeerConnection() {}
 PeerConnection.prototype = {
 
   _pc: null,
   _observer: null,
+  _identity: null,
+
+  // TODO: Refactor this.
   _onCreateOfferSuccess: null,
   _onCreateOfferFailure: null,
   _onCreateAnswerSuccess: null,
   _onCreateAnswerFailure: null,
+  _onSelectIdentitySuccess: null,
+  _onSelectIdentityFailure: null,
+  _onVerifyIdentitySuccess: null,
+  _onVerifyIdentityFailure: null,
 
   _ondatachannel: null,
   _onconnection: null,
   _onclosedconnection: null,
 
   // Everytime we get a request from content, we put it in the queue. If
   // there are no pending operations though, we will execute it immediately.
   // In PeerConnectionObserver, whenever we are notified that an operation
@@ -42,34 +44,122 @@ PeerConnection.prototype = {
   _queue: [],
   _pending: false,
 
   classID: PC_CID,
 
   classInfo: XPCOMUtils.generateCI({classID: PC_CID,
                                     contractID: PC_CONTRACT,
                                     classDescription: "PeerConnection",
-                                    interfaces: [Ci.nsIDOMRTCPeerConnection],
+                                    interfaces: [
+                                      Ci.nsIDOMRTCPeerConnection,
+                                      Ci.nsIDOMGlobalObjectConstructor
+                                    ],
                                     flags: Ci.nsIClassInfo.DOM_OBJECT}),
 
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIDOMRTCPeerConnection]),
+  QueryInterface: XPCOMUtils.generateQI([
+    Ci.nsIDOMRTCPeerConnection, Ci.nsIDOMGlobalObjectConstructor
+  ]),
+
+  // Constructor is an explicit function, because of nsIDOMGlobalObjectConstructor
+  constructor: function(win) {
+    this._pc = Cc["@mozilla.org/peerconnection;1"].
+             createInstance(Ci.IPeerConnection);
+    this._observer = new PeerConnectionObserver(this);
+
+    this._pc.initialize(this._observer, Services.tm.currentThread);
+
+    this._win = win;
+    this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
+                           .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+
+    dump("!!! mozPeerConnection constructor called " + this._win + "\n " + this._winID + "\n\n");
+    this._uniqId = Cc["@mozilla.org/uuid-generator;1"]
+                   .getService(Ci.nsIUUIDGenerator)
+                   .generateUUID().toString();
+  },
 
   // FIXME: Right now we do not enforce proper invocation (eg: calling
   // createOffer twice in a row is allowed).
 
   _queueOrRun: function(obj) {
     if (!this._pending) {
       dump("calling " + obj.func + "\n");
       obj.func.apply(this, obj.args);
       this._pending = true;
     } else {
       this._queue.push(obj);
     }
   },
 
+  // Pick the next item from the queue and run it
+  _executeNext: function() {
+    if (this._queue.length) {
+      let obj = this._queue.shift();
+      obj.func.apply(this, obj.args);
+    } else {
+      this._pending = false;
+    }
+  },
+
+  _selectIdentity: function() {
+    let self = this;
+
+    IDService.selectIdentity(this._uniqId, this._winID, function(err, val) {
+      if (err) {
+        self._onSelectIdentityFailure.onCallback(err);
+      } else {
+        self._identity = val;
+        self._onSelectIdentitySuccess.onCallback(null);
+      }
+      self._executeNext();
+    });
+  },
+
+  _verifyIdentity: function(offer) {
+    let self = this;
+
+    // Extract the a=fingerprint and a=identity lines.
+    let ire = new RegExp("a=identity:(.+)\r\n");
+    let fre = new RegExp("a=fingerprint:(.+)\r\n");
+    
+    let id = offer.match(ire);
+    let fprint = offer.match(fre);
+    
+    if (id.length == 2 && fprint.length == 2) {
+      IDService.verifyIdentity(id[1], function(err, val) {
+        if (val && (fprint[1] == val.message)) {
+          self._onVerifyIdentitySuccess.onCallback(val);
+          return;
+        }
+        self._onVerifyIdentityFailure(err || "Signed message did not match");
+      }); 
+    } else {
+      self._onVerifyIdentityFailure.onCallback("No identity information found");
+    }
+  },
+
+  selectIdentity: function(onSuccess, onError) {
+    dump("!!! selectIdentity called\n");
+    this._onSelectIdentitySuccess = onSuccess;
+    this._onSelectIdentityFailure = onError;
+
+    this._queueOrRun({func: this._selectIdentity, args: null});
+    dump("!!! selectIdentity returned\n");
+  },
+
+  verifyIdentity: function(offer, onSuccess, onError) {
+    dump("!!! verifyIdentity called with\n");
+    this._onVerifyIdentitySuccess = onSuccess;
+    this._onVerifyIdentityFailure = onError;
+
+    this._queueOrRun({func: this._verifyIdentity, args: [offer]});
+    dump("!!! verifyIdentity returned\n");
+  },
+
   createOffer: function(onSuccess, onError, constraints) {
     dump("!!! createOffer called\n");
     this._onCreateOfferSuccess = onSuccess;
     this._onCreateOfferFailure = onError;
 
     // TODO: Implement constraints/hints.
     if (!constraints) {
       constraints = "";
@@ -199,123 +289,143 @@ PeerConnection.prototype = {
 
 // This is a seperate object because we don't want to expose it to DOM.
 function PeerConnectionObserver(dompc) {
   this._dompc = dompc;
 }
 PeerConnectionObserver.prototype = {
   QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
 
-  // Pick the next item from the queue and run it
-  _executeNext: function() {
-    if (this._dompc._queue.length) {
-      let obj = this._dompc._queue.shift();
-      obj.func.apply(this._dompc, obj.args);
-    } else {
-      this._dompc._pending = false;
-    }
-  },
-
   onCreateOfferSuccess: function(offer) {
     dump("!!! onCreateOfferSuccess called\n");
-    if (this._dompc._onCreateOfferSuccess) {
+
+    // Before calling the success callback, check if selectIdentity was
+    // previously called and that an identity was obtained. If so, add
+    // a signed string to the SDP before sending it to content.
+    if (!this._dompc._identity) {
       this._dompc._onCreateOfferSuccess.onCallback(offer);
+      this._dompc._executeNext();
+      return;
     }
-    this._executeNext();
+
+    let sig = this._dompc._pc.fingerprint;
+
+    // FIXME! Save the origin of the window that created the dompc.
+    let self = this;
+    this._dompc._identity.sign("http://example.org", sig, function(e, ast) {
+      if (e && self._dompc._onCreateOfferFailure) {
+        self._dompc._onCreateOfferFailure(e);
+        self._dompc._executeNext();
+        return;
+      }
+
+      // Got assertion, add to the SDP along with the fingerprint. We put
+      // it right at the top, because these must come before the first
+      // m= line.
+      let sigline = "a=fingerprint:" + sig + "\r\n";
+      let idline = "a=identity:" + ast + "\r\n";
+
+      let parts = offer.split("m=");
+      let finalOffer = parts[0] + sigline + idline + "m=" + parts[1];
+
+      dump("!!! Generated final offer: " + finalOffer + "\n\n");
+      self._dompc._onCreateOfferSuccess.onCallback(finalOffer);
+      self._dompc._executeNext();
+    });
   },
 
   onCreateOfferError: function(code) {
     dump("!!! onCreateOfferError called: " + code + "\n");
     if (this._dompc._onCreateOfferFailure) {
       this._dompc._onCreateOfferFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onCreateAnswerSuccess: function(answer) {
     dump("!!! onCreateAnswerSuccess called\n");
     if (this._dompc._onCreateAnswerSuccess) {
       this._dompc._onCreateAnswerSuccess.onCallback(answer);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onCreateAnswerError: function(code) {
     dump("!!! onCreateAnswerError called: " + code + "\n");
     if (this._dompc._onCreateAnswerFailure) {
       this._dompc._onCreateAnswerFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetLocalDescriptionSuccess: function(code) {
     dump("!!! onSetLocalDescriptionSuccess called\n");
     if (this._dompc._onSetLocalDescriptionSuccess) {
       this._dompc._onSetLocalDescriptionSuccess.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetRemoteDescriptionSuccess: function(code) {
     dump("!!! onSetRemoteDescriptionSuccess called\n");
     if (this._dompc._onSetRemoteDescriptionSuccess) {
       this._dompc._onSetRemoteDescriptionSuccess.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetLocalDescriptionError: function(code) {
     dump("!!! onSetLocalDescriptionError called: " + code + "\n");
     if (this._dompc._onSetLocalDescriptionFailure) {
       this._dompc._onSetLocalDescriptionFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetRemoteDescriptionError: function(code) {
     dump("!!! onSetRemoteDescriptionError called: " + code + "\n");
     if (this._dompc._onSetRemoteDescriptionFailure) {
       this._dompc._onSetRemoteDescriptionFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   // FIXME: Following observer events should update state on this._dompc.
   onStateChange: function(state) {
     dump("!!! onStateChange called: " + state + "\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onAddStream: function(stream, type) {
     dump("!!! onAddStream called: " + stream + " :: " + type + "\n");
     if (this._dompc.onRemoteStreamAdded) {
       this._dompc.onRemoteStreamAdded.onCallback({stream: stream, type: type});
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onRemoveStream: function() {
     dump("!!! onRemoveStream called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onAddTrack: function() {
     dump("!!! onAddTrack called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onRemoveTrack: function() {
     dump("!!! onRemoveTrack called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onDataChannel: function() {
     dump("!!! onDataChannel called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   foundIceCandidate: function(candidate) {
     dump("!!! foundIceCandidate called: " + candidate + "\n");
-    this._executeNext();
+    this._dompc._executeNext();
   }
 };
 
 let NSGetFactory = XPCOMUtils.generateNSGetFactory([PeerConnection]);
diff --git a/dom/media/bridge/IPeerConnection.idl b/dom/media/bridge/IPeerConnection.idl
--- a/dom/media/bridge/IPeerConnection.idl
+++ b/dom/media/bridge/IPeerConnection.idl
@@ -85,19 +85,22 @@ interface IPeerConnection : nsISupports
   /* Puts the SIPCC engine back to 'kIdle', shuts down threads, deletes state */
   void close();
 
   /* For testing purposes only! */
   nsIDOMMediaStream createFakeMediaStream(in unsigned long hint);
 
   nsIDOMDataChannel createDataChannel(/* FIX! */);
 
-  /* XXX remove these */	
+  /* XXX remove these */
   void listen(in unsigned short port);
   void connect(in DOMString addr, in unsigned short port);
 
+  /* For identity */
+  readonly attribute string fingerprint;
+
   readonly attribute string localDescription;
   readonly attribute string remoteDescription;
 
   readonly attribute unsigned long iceState;
   readonly attribute unsigned long readyState;
   readonly attribute unsigned long sipccState;
 };
diff --git a/dom/media/nsIDOMRTCPeerConnection.idl b/dom/media/nsIDOMRTCPeerConnection.idl
--- a/dom/media/nsIDOMRTCPeerConnection.idl
+++ b/dom/media/nsIDOMRTCPeerConnection.idl
@@ -46,16 +46,25 @@ interface nsIDOMRTCPeerConnection : nsIS
   void addIceCandidate(in jsval candidate);
 
   void addStream(in nsIDOMMediaStream stream,
     [optional] in jsval constraints);
 
   void removeStream(in nsIDOMMediaStream stream);
   void close();
 
+  /* Identity */
+  void selectIdentity(in RTCPeerConnectionCallback successCallback,
+    [optional] in RTCPeerConnectionCallback failureCallback);
+
+  void verifyIdentity(in jsval offer,
+    in RTCPeerConnectionCallback successCallback,
+    in RTCPeerConnectionCallback failureCallback);
+
+  /* Data channel */
   nsIDOMDataChannel createDataChannel(/* FIX! */);
 
   /* XXX remove these */
   void listen(in unsigned short port);
   void connect(in DOMString addr, in unsigned short port);
 
   attribute nsIDOMEventListener onconnection;
   attribute nsIDOMEventListener onclosedconnection;
diff --git a/dom/media/tests/local_id_test.html b/dom/media/tests/local_id_test.html
new file mode 100644
--- /dev/null
+++ b/dom/media/tests/local_id_test.html
@@ -0,0 +1,119 @@
+<html>
+<head>
+  <title>Simple WebRTC ID Test</title>
+</head>
+<body>
+
+<h1>Simple WebRTC ID Test</h1>
+<div><audio id="tehaudio" controls></audio></div><br/>
+<div><button id="tehbutton" onClick="start();">Start!</button></div><br/>
+<div id="log"></div>
+<div><audio id="localaudio" muted></audio></div><br/>
+
+<script type="application/javascript;version=1.8">
+  function log(msg) {
+    let div = document.getElementById("log");
+    div.innerHTML = div.innerHTML + "<p>" + msg + "</p>";
+  }
+
+  let audio = document.getElementById("tehaudio");
+  let button = document.getElementById("tehbutton");
+  let localaudio = document.getElementById("localaudio");
+
+  let pc1;
+  let pc2;
+
+  let pc1_offer;
+  let pc2_ answer;
+
+  function failed(code) {
+    log("Failure callback: " + code);
+  }
+
+  // pc1.createOffer finished, call pc1.setLocal
+  function step1(offer) {
+    pc1_offer = offer;
+    pc1.setLocalDescription("offer", offer, step2, failed);
+  }
+
+  // pc1.setLocal finished, call pc2.setRemote
+  function step2() {
+    pc2 = new mozPeerConnection();
+    pc2.addStream(pc2.createFakeMediaStream("audio"));
+
+    pc2.onRemoteStreamAdded = function(obj) {
+      log("pc2 got remote stream from pc1 " + obj.type);
+      audio.src = obj.stream;
+      audio.play();
+    }
+
+    pc2.setRemoteDescription("offer", pc1_offer, step3, failed);
+  };
+
+  // pc2.setRemote finished, verify identity
+  function step3() {
+    pc2.verifyIdentity(pc1_offer, step4, failed);
+  }
+
+  // ID verified, call pc2.createAnswer
+  function step4(identity) {
+    log("pc2 verified identity for <b>" + identity.principal.email + "</b>" +
+        " with fingerprint '" + identity.message + "'");
+    pc2.createAnswer(pc1_offer, step5, failed);
+  }
+
+  // pc2.createAnswer finished, call pc2.setLocal
+  function step5(answer) {
+    pc2_answer = answer;
+    pc2.setLocalDescription("answer", answer, step6, failed);
+  }
+
+  // pc2.setLocal finished, call pc1.setRemote
+  function step6() {
+    pc1.setRemoteDescription("answer", pc2_answer, step7, failed);
+  }
+
+  // pc1.setRemote finished, media should be running!
+  function step7() {
+    log("HIP HIP HOORAY");
+  }
+
+  function start() {
+    button.innerHTML = "Stop!";
+    button.onClick = stop;
+
+    pc1 = new mozPeerConnection();
+    pc1.onRemoteStreamAdded = function(obj) {
+      log("pc1 got remote stream from pc2 " + obj.type);
+    }
+
+    log("About to call getusermedia");
+    navigator.mozGetUserMedia({audio:true}, function(stream) {
+      // Add the stream obtained from gUM to an <audio> element to start
+      // the audio flow. We mute it on this end, and assign the "remote"
+      // stream when it arrives at pc2 to an unmuted <audio>.
+      localaudio.src = stream;
+      localaudio.play();
+
+      pc1.addStream(stream);
+
+      // Select ID, then start the chain.
+      pc1.selectIdentity(function(val) {
+        log("pc1 selectIdentity finished successfully");
+        pc1.createOffer(step1, failed);
+      }, function(err) {
+        log("pc1 got error from selectIdentity: " + err);
+      });
+    }, failed);
+  }
+
+  function stop() {
+    pc1.close();
+    pc2.close();
+
+    button.innerHTML = "Start!";
+    button.onClick = start;
+  }
+</script>
+
+</html>
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
@@ -276,16 +276,17 @@ std::map<const std::string, PeerConnecti
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(PeerConnectionImpl, IPeerConnection)
 
 PeerConnectionImpl::PeerConnectionImpl()
 : mRole(kRoleUnknown)
   , mCall(NULL)
   , mReadyState(kNew)
   , mPCObserver(NULL)
+  , mFingerprint("TempFingerprint")
   , mLocalSourceStreamsLock(PR_NewLock())
   , mIceCtx(NULL)
   , mIceStreams(NULL)
   , mIceState(kIceGathering)
   , mIdentity(NULL)
  {}
 
 PeerConnectionImpl::~PeerConnectionImpl()
@@ -827,16 +828,31 @@ PeerConnectionImpl::CloseStreams() {
 NS_IMETHODIMP
 PeerConnectionImpl::AddIceCandidate(const char* strCandidate)
 {
   mCall->addIceCandidate(strCandidate);
   return NS_OK;
 }
 
 NS_IMETHODIMP
+PeerConnectionImpl::GetFingerprint(char** fingerprint)
+{
+  if (!mIdentity) {
+    return NS_ERROR_FAILURE;
+  }
+
+  char* tmp = new char[mFingerprint.size() + 1];
+  std::copy(mFingerprint.begin(), mFingerprint.end(), tmp);
+  tmp[mFingerprint.size()] = '\0';
+
+  *fingerprint = tmp;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 PeerConnectionImpl::GetLocalDescription(char** sdp)
 {
   char* tmp = new char[mLocalSDP.size() + 1];
   std::copy(mLocalSDP.begin(), mLocalSDP.end(), tmp);
   tmp[mLocalSDP.size()] = '\0';
 
   *sdp = tmp;
   return NS_OK;
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
@@ -348,16 +348,19 @@ private:
 
   // The SDP sent in from JS - here for debugging.
   std::string mLocalRequestedSDP;
   std::string mRemoteRequestedSDP;
   // The SDP we are using.
   std::string mLocalSDP;
   std::string mRemoteSDP;
 
+  // DTLS fingerprint, fake it for now.
+  std::string mFingerprint;
+
   // A list of streams returned from GetUserMedia
   PRLock *mLocalSourceStreamsLock;
   nsTArray<nsRefPtr<LocalSourceStreamInfo> > mLocalSourceStreams;
 
   // A list of streams provided by the other side
   PRLock *mRemoteSourceStreamsLock;
   nsTArray<nsRefPtr<RemoteSourceStreamInfo> > mRemoteSourceStreams;
 
diff --git a/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c b/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c
--- a/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c
+++ b/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c
@@ -3078,39 +3078,41 @@ fsmdef_ev_setlocaldesc(sm_event_t *event
         
         cause = gsmsdp_encode_sdp(dcb->sdp, &msg_body);
         if (cause != CC_CAUSE_OK) {
             FSM_DEBUG_SM(get_debug_string(FSM_DBG_SDP_BUILD_ERR));
             ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SETLOCALDESCERROR);
             return (SM_RC_END);	
         }     
         
-        /*compare and fail if different */
+        /* compare and fail if different:
+         * anant: Why? The JS should be able to modify the SDP. Commenting out for now (same for answer)
         if (strcmp(msg_body.parts[0].body, sdp) != 0) {
         	ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SDPCHANGED);
         	return (SM_RC_END);
         }
-        
+        */
+
         fsm_change_state(fcb, __LINE__, FSMDEF_S_CALL_SENT);
 
     } else if (JSEP_ANSWER == action) {
     
     	/* compare SDP generated from CreateAnswer */
         cause = gsmsdp_encode_sdp(dcb->sdp, &msg_body);
         if (cause != CC_CAUSE_OK) {
             FSM_DEBUG_SM(get_debug_string(FSM_DBG_SDP_BUILD_ERR));
             ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SETLOCALDESCERROR);
             return (SM_RC_END);
         }     
         
-        /* compare and fail if different */
+        /* compare and fail if different
         if (strcmp(msg_body.parts[0].body, sdp) != 0) {
             ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SDPCHANGED);
             return (SM_RC_END);
-        }
+        }*/
 
         FSM_SET_FLAGS(dcb->msgs_sent, FSMDEF_MSG_CONNECTED);
 
         
         cc_call_state(dcb->call_id, dcb->line, CC_STATE_ANSWERED,
         	          FSMDEF_CC_CALLER_ID);
 
         fsm_change_state(fcb, __LINE__, FSMDEF_S_CONNECTING);
