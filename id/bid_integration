# HG changeset patch
# Parent 3a25b126b293cf12569cbec940bfa2366183d783

diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -1,38 +1,37 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
+const IDService = {};
 const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/identity/WebRTC.jsm", IDService);
 
 const PC_CONTRACT = "@mozilla.org/dom/peerconnection;1";
 const PC_CID = Components.ID("{7cb2b368-b1ce-4560-acac-8e0dbda7d3d0}");
 
-function PeerConnection() {
-  this._pc = Cc["@mozilla.org/peerconnection;1"].
-             createInstance(Ci.IPeerConnection);
-  this._observer = new PeerConnectionObserver(this);
-
-  dump("!!! mozPeerConnection constructor called " + this._pc + "\n\n");
-  this._pc.initialize(this._observer, Services.tm.currentThread);
-}
+function PeerConnection() {}
 PeerConnection.prototype = {
 
   _pc: null,
   _observer: null,
+  _identity: null,
+
   _onCreateOfferSuccess: null,
   _onCreateOfferFailure: null,
   _onCreateAnswerSuccess: null,
   _onCreateAnswerFailure: null,
+  _onSelectIdentitySuccess: null,
+  _onSelectIdentityFailure: null,
 
   _ondatachannel: null,
   _onconnection: null,
   _onclosedconnection: null,
 
   // Everytime we get a request from content, we put it in the queue. If
   // there are no pending operations though, we will execute it immediately.
   // In PeerConnectionObserver, whenever we are notified that an operation
@@ -42,34 +41,90 @@ PeerConnection.prototype = {
   _queue: [],
   _pending: false,
 
   classID: PC_CID,
 
   classInfo: XPCOMUtils.generateCI({classID: PC_CID,
                                     contractID: PC_CONTRACT,
                                     classDescription: "PeerConnection",
-                                    interfaces: [Ci.nsIDOMRTCPeerConnection],
+                                    interfaces: [
+                                      Ci.nsIDOMRTCPeerConnection,
+                                      Ci.nsIDOMGlobalObjectConstructor
+                                    ],
                                     flags: Ci.nsIClassInfo.DOM_OBJECT}),
 
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIDOMRTCPeerConnection]),
+  QueryInterface: XPCOMUtils.generateQI([
+    Ci.nsIDOMRTCPeerConnection, Ci.nsIDOMGlobalObjectConstructor
+  ]),
+
+  // Constructor is an explicit function, because of nsIDOMGlobalObjectConstructor
+  constructor: function(win) {
+    this._pc = Cc["@mozilla.org/peerconnection;1"].
+             createInstance(Ci.IPeerConnection);
+    this._observer = new PeerConnectionObserver(this);
+
+    this._pc.initialize(this._observer, Services.tm.currentThread);
+
+    this._win = win;
+    this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
+                           .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+
+    dump("!!! mozPeerConnection constructor called " + this._win + "\n " + this._winID + "\n\n");
+    this._uniqId = Cc["@mozilla.org/uuid-generator;1"]
+                   .getService(Ci.nsIUUIDGenerator)
+                   .generateUUID().toString();
+  },
 
   // FIXME: Right now we do not enforce proper invocation (eg: calling
   // createOffer twice in a row is allowed).
 
   _queueOrRun: function(obj) {
     if (!this._pending) {
       dump("calling " + obj.func + "\n");
       obj.func.apply(this, obj.args);
       this._pending = true;
     } else {
       this._queue.push(obj);
     }
   },
 
+  // Pick the next item from the queue and run it
+  _executeNext: function() {
+    if (this._queue.length) {
+      let obj = this._queue.shift();
+      obj.func.apply(this, obj.args);
+    } else {
+      this._pending = false;
+    }
+  },
+
+  _selectIdentity: function() {
+    let self = this;
+
+    IDService.selectIdentity(this._uniqId, this._winID, function(err, val) {
+      if (err) {
+        self._onSelectIdentityFailure.onCallback(err);
+      } else {
+        self._identity = val;
+        self._onSelectIdentitySuccess.onCallback(null);
+      }
+      self._executeNext();
+    });
+  },
+
+  selectIdentity: function(onSuccess, onError) {
+    dump("!!! selectIdentity called with " + onSuccess + " :: " + onError + "\n\n");
+    this._onSelectIdentitySuccess = onSuccess;
+    this._onSelectIdentityFailure = onError;
+
+    this._queueOrRun({func: this._selectIdentity, args: null});
+    dump("!!! selectIdentity returned\n");
+  },
+
   createOffer: function(onSuccess, onError, constraints) {
     dump("!!! createOffer called\n");
     this._onCreateOfferSuccess = onSuccess;
     this._onCreateOfferFailure = onError;
 
     // TODO: Implement constraints/hints.
     if (!constraints) {
       constraints = "";
@@ -199,123 +254,145 @@ PeerConnection.prototype = {
 
 // This is a seperate object because we don't want to expose it to DOM.
 function PeerConnectionObserver(dompc) {
   this._dompc = dompc;
 }
 PeerConnectionObserver.prototype = {
   QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
 
-  // Pick the next item from the queue and run it
-  _executeNext: function() {
-    if (this._dompc._queue.length) {
-      let obj = this._dompc._queue.shift();
-      obj.func.apply(this._dompc, obj.args);
-    } else {
-      this._dompc._pending = false;
-    }
-  },
-
   onCreateOfferSuccess: function(offer) {
     dump("!!! onCreateOfferSuccess called\n");
-    if (this._dompc._onCreateOfferSuccess) {
+
+    // Before calling the success callback, check if selectIdentity was
+    // previously called and that an identity was obtained. If so, add
+    // a signed string to the SDP before sending it to content.
+    if (!this._dompc._identity) {
       this._dompc._onCreateOfferSuccess.onCallback(offer);
+      this._dompc._executeNext();
+      return;
     }
-    this._executeNext();
+
+    let sig = this._dompc._pc.fingerprint;
+    dump("!!! Got fingerprint from PC: " + sig + "\n\n");
+
+    // FIXME! Save the origin of the window that created the dompc.
+    let self = this;
+    this._dompc._identity.sign("http://example.org", sig, function(e, ast) {
+      dump("!!! AuthModule.sign returned: " + e + " :: " + ast + "\n");
+      if (e && self._dompc._onCreateOfferFailure) {
+        self._dompc._onCreateOfferFailure(e);
+        self._dompc._executeNext();
+        return;
+      }
+
+      // Got assertion, add to the SDP along with the fingerprint. We put
+      // it right at the top, because these must come before the first
+      // m= line.
+      let sigline = "a=fingerprint: " + sig + "\r\n";
+      //let idline = "a=identity: " + ast + "\r\n";
+      //offer = sigline + idline + offer;
+
+      let parts = offer.split("m=");
+      let finalOffer = parts[0] + sigline + "m=" + parts[1];
+      dump("!!! Generated final offer: " + finalOffer + "\n\n");
+      self._dompc._onCreateOfferSuccess.onCallback(finalOffer);
+      self._dompc._executeNext();
+    });
   },
 
   onCreateOfferError: function(code) {
     dump("!!! onCreateOfferError called: " + code + "\n");
     if (this._dompc._onCreateOfferFailure) {
       this._dompc._onCreateOfferFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onCreateAnswerSuccess: function(answer) {
     dump("!!! onCreateAnswerSuccess called\n");
     if (this._dompc._onCreateAnswerSuccess) {
       this._dompc._onCreateAnswerSuccess.onCallback(answer);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onCreateAnswerError: function(code) {
     dump("!!! onCreateAnswerError called: " + code + "\n");
     if (this._dompc._onCreateAnswerFailure) {
       this._dompc._onCreateAnswerFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetLocalDescriptionSuccess: function(code) {
     dump("!!! onSetLocalDescriptionSuccess called\n");
     if (this._dompc._onSetLocalDescriptionSuccess) {
       this._dompc._onSetLocalDescriptionSuccess.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetRemoteDescriptionSuccess: function(code) {
     dump("!!! onSetRemoteDescriptionSuccess called\n");
     if (this._dompc._onSetRemoteDescriptionSuccess) {
       this._dompc._onSetRemoteDescriptionSuccess.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetLocalDescriptionError: function(code) {
     dump("!!! onSetLocalDescriptionError called: " + code + "\n");
     if (this._dompc._onSetLocalDescriptionFailure) {
       this._dompc._onSetLocalDescriptionFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onSetRemoteDescriptionError: function(code) {
     dump("!!! onSetRemoteDescriptionError called: " + code + "\n");
     if (this._dompc._onSetRemoteDescriptionFailure) {
       this._dompc._onSetRemoteDescriptionFailure.onCallback(code);
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   // FIXME: Following observer events should update state on this._dompc.
   onStateChange: function(state) {
     dump("!!! onStateChange called: " + state + "\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onAddStream: function(stream, type) {
     dump("!!! onAddStream called: " + stream + " :: " + type + "\n");
     if (this._dompc.onRemoteStreamAdded) {
       this._dompc.onRemoteStreamAdded.onCallback({stream: stream, type: type});
     }
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onRemoveStream: function() {
     dump("!!! onRemoveStream called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onAddTrack: function() {
     dump("!!! onAddTrack called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onRemoveTrack: function() {
     dump("!!! onRemoveTrack called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   onDataChannel: function() {
     dump("!!! onDataChannel called\n");
-    this._executeNext();
+    this._dompc._executeNext();
   },
 
   foundIceCandidate: function(candidate) {
     dump("!!! foundIceCandidate called: " + candidate + "\n");
-    this._executeNext();
+    this._dompc._executeNext();
   }
 };
 
 let NSGetFactory = XPCOMUtils.generateNSGetFactory([PeerConnection]);
diff --git a/dom/media/bridge/IPeerConnection.idl b/dom/media/bridge/IPeerConnection.idl
--- a/dom/media/bridge/IPeerConnection.idl
+++ b/dom/media/bridge/IPeerConnection.idl
@@ -85,19 +85,22 @@ interface IPeerConnection : nsISupports
   /* Puts the SIPCC engine back to 'kIdle', shuts down threads, deletes state */
   void close();
 
   /* For testing purposes only! */
   nsIDOMMediaStream createFakeMediaStream(in unsigned long hint);
 
   nsIDOMDataChannel createDataChannel(/* FIX! */);
 
-  /* XXX remove these */	
+  /* XXX remove these */
   void listen(in unsigned short port);
   void connect(in DOMString addr, in unsigned short port);
 
+  /* For identity */
+  readonly attribute string fingerprint;
+
   readonly attribute string localDescription;
   readonly attribute string remoteDescription;
 
   readonly attribute unsigned long iceState;
   readonly attribute unsigned long readyState;
   readonly attribute unsigned long sipccState;
 };
diff --git a/dom/media/nsIDOMRTCPeerConnection.idl b/dom/media/nsIDOMRTCPeerConnection.idl
--- a/dom/media/nsIDOMRTCPeerConnection.idl
+++ b/dom/media/nsIDOMRTCPeerConnection.idl
@@ -46,16 +46,20 @@ interface nsIDOMRTCPeerConnection : nsIS
   void addIceCandidate(in jsval candidate);
 
   void addStream(in nsIDOMMediaStream stream,
     [optional] in jsval constraints);
 
   void removeStream(in nsIDOMMediaStream stream);
   void close();
 
+  /* Identity */
+  void selectIdentity(in RTCPeerConnectionCallback successCallback,
+    [optional] in RTCPeerConnectionCallback failureCallback);
+
   nsIDOMDataChannel createDataChannel(/* FIX! */);
 
   /* XXX remove these */
   void listen(in unsigned short port);
   void connect(in DOMString addr, in unsigned short port);
 
   attribute nsIDOMEventListener onconnection;
   attribute nsIDOMEventListener onclosedconnection;
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
@@ -276,16 +276,17 @@ std::map<const std::string, PeerConnecti
 
 NS_IMPL_THREADSAFE_ISUPPORTS1(PeerConnectionImpl, IPeerConnection)
 
 PeerConnectionImpl::PeerConnectionImpl()
 : mRole(kRoleUnknown)
   , mCall(NULL)
   , mReadyState(kNew)
   , mPCObserver(NULL)
+  , mFingerprint("TempFingerprint")
   , mLocalSourceStreamsLock(PR_NewLock())
   , mIceCtx(NULL)
   , mIceStreams(NULL)
   , mIceState(kIceGathering)
   , mIdentity(NULL)
  {}
 
 PeerConnectionImpl::~PeerConnectionImpl()
@@ -827,16 +828,31 @@ PeerConnectionImpl::CloseStreams() {
 NS_IMETHODIMP
 PeerConnectionImpl::AddIceCandidate(const char* strCandidate)
 {
   mCall->addIceCandidate(strCandidate);
   return NS_OK;
 }
 
 NS_IMETHODIMP
+PeerConnectionImpl::GetFingerprint(char** fingerprint)
+{
+  if (!mIdentity) {
+    return NS_ERROR_FAILURE;
+  }
+
+  char* tmp = new char[mFingerprint.size() + 1];
+  std::copy(mFingerprint.begin(), mFingerprint.end(), tmp);
+  tmp[mFingerprint.size()] = '\0';
+
+  *fingerprint = tmp;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 PeerConnectionImpl::GetLocalDescription(char** sdp)
 {
   char* tmp = new char[mLocalSDP.size() + 1];
   std::copy(mLocalSDP.begin(), mLocalSDP.end(), tmp);
   tmp[mLocalSDP.size()] = '\0';
 
   *sdp = tmp;
   return NS_OK;
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.h
@@ -348,16 +348,19 @@ private:
 
   // The SDP sent in from JS - here for debugging.
   std::string mLocalRequestedSDP;
   std::string mRemoteRequestedSDP;
   // The SDP we are using.
   std::string mLocalSDP;
   std::string mRemoteSDP;
 
+  // DTLS fingerprint, fake it for now.
+  std::string mFingerprint;
+
   // A list of streams returned from GetUserMedia
   PRLock *mLocalSourceStreamsLock;
   nsTArray<nsRefPtr<LocalSourceStreamInfo> > mLocalSourceStreams;
 
   // A list of streams provided by the other side
   PRLock *mRemoteSourceStreamsLock;
   nsTArray<nsRefPtr<RemoteSourceStreamInfo> > mRemoteSourceStreams;
 
diff --git a/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c b/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c
--- a/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c
+++ b/media/webrtc/signaling/src/sipcc/core/gsm/fsmdef.c
@@ -3078,39 +3078,41 @@ fsmdef_ev_setlocaldesc(sm_event_t *event
         
         cause = gsmsdp_encode_sdp(dcb->sdp, &msg_body);
         if (cause != CC_CAUSE_OK) {
             FSM_DEBUG_SM(get_debug_string(FSM_DBG_SDP_BUILD_ERR));
             ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SETLOCALDESCERROR);
             return (SM_RC_END);	
         }     
         
-        /*compare and fail if different */
+        /* compare and fail if different:
+         * anant: Why? The JS should be able to modify the SDP. Commenting out for now (same for answer)
         if (strcmp(msg_body.parts[0].body, sdp) != 0) {
         	ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SDPCHANGED);
         	return (SM_RC_END);
         }
-        
+        */
+
         fsm_change_state(fcb, __LINE__, FSMDEF_S_CALL_SENT);
 
     } else if (JSEP_ANSWER == action) {
     
     	/* compare SDP generated from CreateAnswer */
         cause = gsmsdp_encode_sdp(dcb->sdp, &msg_body);
         if (cause != CC_CAUSE_OK) {
             FSM_DEBUG_SM(get_debug_string(FSM_DBG_SDP_BUILD_ERR));
             ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SETLOCALDESCERROR);
             return (SM_RC_END);
         }     
         
-        /* compare and fail if different */
+        /* compare and fail if different
         if (strcmp(msg_body.parts[0].body, sdp) != 0) {
             ui_set_local_description(evSetLocalDescError, line, call_id, dcb->caller_id.call_instance_id, NULL, PC_SDPCHANGED);
             return (SM_RC_END);
-        }
+        }*/
 
         FSM_SET_FLAGS(dcb->msgs_sent, FSMDEF_MSG_CONNECTED);
 
         
         cc_call_state(dcb->call_id, dcb->line, CC_STATE_ANSWERED,
         	          FSMDEF_CC_CALLER_ID);
 
         fsm_change_state(fcb, __LINE__, FSMDEF_S_CONNECTING);
