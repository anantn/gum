# HG changeset patch
# Parent c721c3b30eab7ad7859a608a07b27c3629c1af00

diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -5721,21 +5721,31 @@ BaseStubConstructor(nsIWeakReference* aW
       // Check if the object is even callable.
       NS_ENSURE_STATE(JS_ObjectIsCallable(cx, &funval.toObject()));
       thisValue.setObject(*object);
 
       {
         JSObject* thisObject = &thisValue.toObject();
 
         // wrap parameters in the target compartment
+        // we also pass in the calling window as the first argument
+        ++argc;
         nsAutoArrayPtr<JS::Value> args(new JS::Value[argc]);
         JS::AutoArrayRooter rooter(cx, 0, args);
 
-        for (size_t i = 0; i < argc; ++i) {
-          args[i] = argv[i];
+        nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
+        nsCOMPtr<nsIDOMWindow> currentWin(do_GetInterface(currentInner));
+        rv = WrapNative(cx, obj, currentWin, &NS_GET_IID(nsIDOMWindow),
+                        true, &args[0], getter_AddRefs(holder));
+        if (!JS_WrapValue(cx, &args[0]))
+          return NS_ERROR_FAILURE;
+        rooter.changeLength(1);
+
+        for (size_t i = 1; i < argc; ++i) {
+          args[i] = argv[i - 1];
           if (!JS_WrapValue(cx, &args[i]))
             return NS_ERROR_FAILURE;
           rooter.changeLength(i + 1);
         }
 
         JS::Value frval;
         bool ret = JS_CallFunctionValue(cx, thisObject, funval, argc, args, &frval);
 
