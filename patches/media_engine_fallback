# HG changeset patch
# Parent 3579dbd8c1d89c64e34ed8f445e69a1ccc7360af
# User Anant Narayanan <anant@kix.in>
Implement fallback media engine

diff --git a/content/media/Makefile.in b/content/media/Makefile.in
--- a/content/media/Makefile.in
+++ b/content/media/Makefile.in
@@ -54,6 +54,7 @@
   AudioSegment.h \
   FileBlockCache.h \
   MediaEngine.h \
+  MediaEngineDefault.h \
   MediaResource.h \
   MediaSegment.h \
   MediaStreamGraph.h \
@@ -75,6 +76,7 @@
 CPPSRCS = \
   AudioSegment.cpp \
   FileBlockCache.cpp \
+  MediaEngineDefault.cpp \
   MediaResource.cpp \
   MediaStreamGraph.cpp \
   nsAudioAvailableEventManager.cpp \
diff --git a/content/media/MediaEngineDefault.cpp b/content/media/MediaEngineDefault.cpp
new file mode 100644
--- /dev/null
+++ b/content/media/MediaEngineDefault.cpp
@@ -0,0 +1,259 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "MediaEngineDefault.h"
+
+#define WIDTH 320
+#define HEIGHT 240
+#define FPS 10
+#define CHANNELS 1
+
+#define TRACK_VIDEO 1
+#define TRACK_AUDIO 2
+#define RATE USECS_PER_S
+
+namespace mozilla {
+
+NS_IMPL_ISUPPORTS1(MediaEngineDefaultVideoSource, nsITimerCallback)
+/**
+ * Default video source.
+ */
+void
+MediaEngineDefaultVideoSource::GetName(nsAString& aName)
+{
+  aName.Assign(NS_LITERAL_STRING("Default Video Device"));
+  return;
+}
+
+void
+MediaEngineDefaultVideoSource::GetUUID(nsAString& aUUID)
+{
+  aUUID.Assign(NS_LITERAL_STRING("1041FCBD-3F12-4F7B-9E9B-1EC556DD5676"));
+  return;
+}
+
+already_AddRefed<nsDOMMediaStream>
+MediaEngineDefaultVideoSource::Allocate()
+{
+  if (mState != kReleased) {
+    return NULL;
+  }
+
+  mState = kAllocated;
+  return nsDOMMediaStream::CreateInputStream();
+}
+
+nsresult
+MediaEngineDefaultVideoSource::Deallocate()
+{
+  if (mState != kStopped && mState != kAllocated) {
+    return NS_ERROR_FAILURE;
+  }
+  mState = kReleased;
+  return NS_OK;
+}
+
+MediaEngineVideoOptions
+MediaEngineDefaultVideoSource::GetOptions()
+{
+  MediaEngineVideoOptions aOpts;
+  aOpts.mWidth = WIDTH;
+  aOpts.mHeight = HEIGHT;
+  aOpts.mMaxFPS = FPS;
+  aOpts.codecType = kVideoCodecI420;
+  return aOpts;
+}
+
+nsresult
+MediaEngineDefaultVideoSource::Start(SourceMediaStream* aStream, TrackID aID)
+{
+  if (mState != kAllocated) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+  if (!mTimer) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mSource = aStream;
+
+  // Allocate a single blank Image
+  layers::Image::Format format = layers::Image::PLANAR_YCBCR;
+  mImageContainer = layers::LayerManager::CreateImageContainer();
+    
+  nsRefPtr<layers::Image> image = mImageContainer->CreateImage(&format, 1);
+  
+  mImage = static_cast<layers::PlanarYCbCrImage*>(image.get());
+  PRUint8* frame = (PRUint8*) PR_Calloc((WIDTH * HEIGHT) / 2, 3);
+  const PRUint8 lumaBpp = 8;
+  const PRUint8 chromaBpp = 4; 
+
+  layers::PlanarYCbCrImage::Data data;
+  data.mYChannel = frame;
+  data.mYSize = gfxIntSize(WIDTH, HEIGHT);
+  data.mYStride = WIDTH * lumaBpp / 8.0;
+  data.mCbCrStride = WIDTH * chromaBpp / 8.0;
+  data.mCbChannel = frame + HEIGHT * data.mYStride;
+  data.mCrChannel = data.mCbChannel + HEIGHT * data.mCbCrStride / 2;
+  data.mCbCrSize = gfxIntSize(WIDTH / 2, HEIGHT / 2);
+  data.mPicX = 0;
+  data.mPicY = 0;
+  data.mPicSize = gfxIntSize(WIDTH, HEIGHT);
+  data.mStereoMode = layers::STEREO_MODE_MONO;
+
+  // SetData copies data, so we can free the frame
+  mImage->SetData(data);
+  PR_Free(frame);
+
+  // AddTrack takes ownership of segment
+  VideoSegment *segment = new VideoSegment();
+  segment->AppendFrame(image.forget(), USECS_PER_S / FPS, gfxIntSize(WIDTH, HEIGHT));
+  mSource->AddTrack(aID, RATE, 0, segment);
+
+  // Start timer for subsequent frames
+  mTimer->InitWithCallback(this, 1000 / FPS, nsITimer::TYPE_REPEATING_SLACK);
+  mState = kStarted;
+  
+  return NS_OK;
+}
+
+nsresult
+MediaEngineDefaultVideoSource::Stop()
+{
+  if (mState != kStarted) {
+    return NS_ERROR_FAILURE;
+  }
+  if (!mTimer) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mTimer->Cancel();
+  mTimer = NULL;
+  mState = kStopped;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+MediaEngineDefaultVideoSource::Notify(nsITimer* aTimer)
+{
+  VideoSegment segment;
+
+  nsRefPtr<layers::PlanarYCbCrImage> image = mImage;
+  segment.AppendFrame(image.forget(), USECS_PER_S / FPS, gfxIntSize(WIDTH, HEIGHT));
+  mSource->AppendToTrack(TRACK_VIDEO, &segment);
+
+  return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS1(MediaEngineDefaultAudioSource, nsITimerCallback)
+/**
+ * Default audio source.
+ */
+void
+MediaEngineDefaultAudioSource::GetName(nsAString& aName)
+{
+  aName.Assign(NS_LITERAL_STRING("Default Audio Device"));
+  return;
+}
+
+void
+MediaEngineDefaultAudioSource::GetUUID(nsAString& aUUID)
+{
+  aUUID.Assign(NS_LITERAL_STRING("B7CBD7C1-53EF-42F9-8353-73F61C70C092"));
+  return;
+}
+
+already_AddRefed<nsDOMMediaStream>
+MediaEngineDefaultAudioSource::Allocate()
+{
+  if (mState != kReleased) {
+    return NULL;
+  }
+  mState = kAllocated;
+  return nsDOMMediaStream::CreateInputStream();
+}
+
+nsresult
+MediaEngineDefaultAudioSource::Deallocate()
+{
+  if (mState != kStopped && mState != kAllocated) {
+    return NS_ERROR_FAILURE;
+  }
+  mState = kReleased;
+  return NS_OK;
+}
+
+nsresult
+MediaEngineDefaultAudioSource::Start(SourceMediaStream* aStream, TrackID aID)
+{
+  if (mState != kAllocated) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+  if (!mTimer) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mSource = aStream;
+
+  // AddTrack will take ownership of segment
+  AudioSegment* segment = new AudioSegment();
+  segment->Init(CHANNELS);
+  mSource->AddTrack(aID, RATE, 0, segment);
+
+  // 1 Audio frame per Video frame.
+  mTimer->InitWithCallback(this, 1000 / FPS, nsITimer::TYPE_REPEATING_SLACK);
+  mState = kStarted;
+
+  return NS_OK;
+}
+
+nsresult
+MediaEngineDefaultAudioSource::Stop()
+{
+  if (mState != kStarted) {
+    return NS_ERROR_FAILURE;
+  }
+  if (!mTimer) {
+    return NS_ERROR_FAILURE;
+  }
+
+  mTimer->Cancel();
+  mTimer = NULL;
+  mState = kStopped;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+MediaEngineDefaultAudioSource::Notify(nsITimer* aTimer)
+{
+  AudioSegment segment;
+  segment.Init(CHANNELS);
+  segment.InsertNullDataAtStart(1); // One tick?
+
+  mSource->AppendToTrack(TRACK_AUDIO, &segment);
+
+  return NS_OK;
+}
+
+void
+MediaEngineDefault::EnumerateVideoDevices(
+  nsTArray<nsAutoPtr<MediaEngineVideoSource> >* aVsources) {
+
+  MediaEngineVideoSource* source = mVsource;
+  aVsources->AppendElement(source);
+  return;
+}
+
+void
+MediaEngineDefault::EnumerateAudioDevices(
+  nsTArray<nsAutoPtr<MediaEngineAudioSource> >* aAsources) {
+
+  MediaEngineAudioSource* source = mAsource;
+  aAsources->AppendElement(source);
+  return;
+}
+}
diff --git a/content/media/MediaEngineDefault.h b/content/media/MediaEngineDefault.h
new file mode 100644
--- /dev/null
+++ b/content/media/MediaEngineDefault.h
@@ -0,0 +1,113 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MEDIAENGINEDEFAULT_H_
+#define MEDIAENGINEDEFAULT_H_
+
+#include "prmem.h"
+#include "nsITimer.h"
+
+#include "nsCOMPtr.h"
+#include "nsDOMMediaStream.h"
+#include "nsComponentManagerUtils.h"
+
+#include "Layers.h"
+#include "VideoUtils.h"
+#include "MediaEngine.h"
+#include "ImageLayers.h"
+#include "VideoSegment.h"
+#include "AudioSegment.h"
+#include "StreamBuffer.h"
+#include "MediaStreamGraph.h"
+
+namespace mozilla {
+
+/**
+ * The default implementation of the MediaEngine interface.
+ */
+
+enum DefaultEngineState {
+  kAllocated,
+  kStarted,
+  kStopped,
+  kReleased
+};
+
+class MediaEngineDefaultVideoSource : public nsITimerCallback,
+                                      public MediaEngineVideoSource
+                                        
+{
+public:
+  MediaEngineDefaultVideoSource() : mTimer(nsnull), mState(kReleased) {}
+  ~MediaEngineDefaultVideoSource(){};
+
+  void GetName(nsAString&);
+  void GetUUID(nsAString&);
+
+  MediaEngineVideoOptions GetOptions();
+  already_AddRefed<nsDOMMediaStream> Allocate();
+
+  nsresult Deallocate();
+  nsresult Start(SourceMediaStream*, TrackID);
+  nsresult Stop();
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSITIMERCALLBACK
+
+protected:
+  nsCOMPtr<nsITimer> mTimer;
+  nsRefPtr<layers::ImageContainer> mImageContainer;
+
+  DefaultEngineState mState;
+  SourceMediaStream* mSource;
+  nsRefPtr<layers::PlanarYCbCrImage> mImage;
+};
+
+class MediaEngineDefaultAudioSource : public nsITimerCallback,
+                                      public MediaEngineAudioSource
+                                        
+{
+public:
+  MediaEngineDefaultAudioSource() : mTimer(nsnull), mState(kReleased) {}
+  ~MediaEngineDefaultAudioSource(){};
+
+  void GetName(nsAString&);
+  void GetUUID(nsAString&);
+
+  already_AddRefed<nsDOMMediaStream> Allocate();
+
+  nsresult Deallocate();
+  nsresult Start(SourceMediaStream*, TrackID);
+  nsresult Stop();
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSITIMERCALLBACK
+
+protected:
+  nsCOMPtr<nsITimer> mTimer;
+
+  DefaultEngineState mState;
+  SourceMediaStream* mSource;
+};
+
+class MediaEngineDefault : public MediaEngine
+{
+public:
+  MediaEngineDefault() {
+    mVsource = new MediaEngineDefaultVideoSource();
+    mAsource = new MediaEngineDefaultAudioSource();
+  }
+  ~MediaEngineDefault() {}
+
+  void EnumerateVideoDevices(nsTArray<nsAutoPtr<MediaEngineVideoSource> >*);
+  void EnumerateAudioDevices(nsTArray<nsAutoPtr<MediaEngineAudioSource> >*);
+
+private:
+  nsAutoPtr<MediaEngineVideoSource> mVsource;
+  nsAutoPtr<MediaEngineAudioSource> mAsource;
+};
+
+}
+
+#endif /* NSMEDIAENGINEDEFAULT_H_ */
\ No newline at end of file
