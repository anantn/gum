# HG changeset patch
# Parent 0fd2a24730e03c7960d408f181fa3b1a4559b541
# User Anant Narayanan <anant@kix.in>
DOM bindings for gUM

diff --git a/b2g/installer/package-manifest.in b/b2g/installer/package-manifest.in
--- a/b2g/installer/package-manifest.in
+++ b/b2g/installer/package-manifest.in
@@ -137,17 +137,16 @@
 @BINPATH@/components/commandhandler.xpt
 @BINPATH@/components/commandlines.xpt
 @BINPATH@/components/composer.xpt
 @BINPATH@/components/content_base.xpt
 @BINPATH@/components/content_events.xpt
 @BINPATH@/components/content_canvas.xpt
 @BINPATH@/components/content_htmldoc.xpt
 @BINPATH@/components/content_html.xpt
-@BINPATH@/components/content_media.xpt
 @BINPATH@/components/content_xslt.xpt
 @BINPATH@/components/content_xtf.xpt
 @BINPATH@/components/cookie.xpt
 @BINPATH@/components/directory.xpt
 @BINPATH@/components/docshell.xpt
 @BINPATH@/components/dom.xpt
 @BINPATH@/components/dom_apps.xpt
 @BINPATH@/components/dom_base.xpt
@@ -162,16 +161,17 @@
 #endif
 @BINPATH@/components/dom_canvas.xpt
 @BINPATH@/components/dom_contacts.xpt
 @BINPATH@/components/dom_core.xpt
 @BINPATH@/components/dom_css.xpt
 @BINPATH@/components/dom_devicestorage.xpt
 @BINPATH@/components/dom_events.xpt
 @BINPATH@/components/dom_geolocation.xpt
+@BINPATH@/components/dom_media.xpt
 @BINPATH@/components/dom_network.xpt
 @BINPATH@/components/dom_notification.xpt
 @BINPATH@/components/dom_html.xpt
 @BINPATH@/components/dom_indexeddb.xpt
 @BINPATH@/components/dom_offline.xpt
 @BINPATH@/components/dom_json.xpt
 @BINPATH@/components/dom_power.xpt
 @BINPATH@/components/dom_range.xpt
diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -1,13 +1,13 @@
 ; This Source Code Form is subject to the terms of the Mozilla Public
 ; License, v. 2.0. If a copy of the MPL was not distributed with this
 ; file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-; Package file for the Firefox build. 
+; Package file for the Firefox build.
 ;
 ; Packaging manifest is used to copy files from dist/bin
 ; to the staging directory.
 ; Some other files are built in the staging directory directly,
 ; so they will be implicitly packaged too.
 ;
 ; File format:
 ;
@@ -142,17 +142,16 @@
 @BINPATH@/components/commandhandler.xpt
 @BINPATH@/components/commandlines.xpt
 @BINPATH@/components/composer.xpt
 @BINPATH@/components/content_base.xpt
 @BINPATH@/components/content_events.xpt
 @BINPATH@/components/content_canvas.xpt
 @BINPATH@/components/content_htmldoc.xpt
 @BINPATH@/components/content_html.xpt
-@BINPATH@/components/content_media.xpt
 @BINPATH@/components/content_xslt.xpt
 @BINPATH@/components/content_xtf.xpt
 @BINPATH@/components/cookie.xpt
 @BINPATH@/components/directory.xpt
 @BINPATH@/components/docshell.xpt
 @BINPATH@/components/dom.xpt
 @BINPATH@/components/dom_apps.xpt
 @BINPATH@/components/dom_base.xpt
@@ -167,16 +166,17 @@
 #endif
 @BINPATH@/components/dom_canvas.xpt
 @BINPATH@/components/dom_contacts.xpt
 @BINPATH@/components/dom_core.xpt
 @BINPATH@/components/dom_css.xpt
 @BINPATH@/components/dom_devicestorage.xpt
 @BINPATH@/components/dom_events.xpt
 @BINPATH@/components/dom_geolocation.xpt
+@BINPATH@/components/dom_media.xpt
 @BINPATH@/components/dom_network.xpt
 @BINPATH@/components/dom_notification.xpt
 @BINPATH@/components/dom_html.xpt
 @BINPATH@/components/dom_indexeddb.xpt
 @BINPATH@/components/dom_offline.xpt
 @BINPATH@/components/dom_json.xpt
 @BINPATH@/components/dom_power.xpt
 @BINPATH@/components/dom_range.xpt
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -4543,16 +4543,17 @@ MOZ_SPEEX_RESAMPLER=1
 MOZ_CUBEB=
 MOZ_VORBIS=
 MOZ_TREMOR=
 MOZ_WAVE=1
 MOZ_MEDIA=
 MOZ_OPUS=1
 MOZ_WEBM=1
 MOZ_MEDIA_PLUGINS=
+MOZ_MEDIA_NAVIGATOR=
 MOZ_OMX_PLUGIN=
 MOZ_VP8_ERROR_CONCEALMENT=
 MOZ_VP8_ENCODER=
 VPX_AS=
 VPX_ASFLAGS=
 VPX_AS_DASH_C_FLAG=
 VPX_AS_CONVERSION=
 VPX_ASM_SUFFIX=
@@ -5634,16 +5635,28 @@ MOZ_ARG_ENABLE_BOOL(media-plugins,
     MOZ_MEDIA_PLUGINS=1,
     MOZ_MEDIA_PLUGINS=)
 
 if test -n "$MOZ_MEDIA_PLUGINS"; then
   AC_DEFINE(MOZ_MEDIA_PLUGINS)
 fi
 
 dnl ========================================================
+dnl = Enable getUserMedia support
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(media-navigator,
+[  --enable-media-navigator  Enable support for getUserMedia],
+    MOZ_MEDIA_NAVIGATOR=1,
+    MOZ_MEDIA_NAVIGATOR=)
+
+if test -n "$MOZ_MEDIA_NAVIGATOR"; then
+  AC_DEFINE(MOZ_MEDIA_NAVIGATOR)
+fi
+
+dnl ========================================================
 dnl = Enable building OMX media plugin (B2G)
 dnl ========================================================
 MOZ_ARG_ENABLE_BOOL(omx-plugin,
 [  --enable-omx-plugin      Enable building OMX plugin (B2G)],
     MOZ_OMX_PLUGIN=1,
     MOZ_OMX_PLUGIN=)
 
 if test -n "$MOZ_OMX_PLUGIN"; then
diff --git a/content/media/Makefile.in b/content/media/Makefile.in
--- a/content/media/Makefile.in
+++ b/content/media/Makefile.in
@@ -7,21 +7,16 @@ topsrcdir = @top_srcdir@
 srcdir    = @srcdir@
 VPATH     = @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MODULE = content
 LIBRARY_NAME = gkconmedia_s
 LIBXUL_LIBRARY = 1
-XPIDL_MODULE = content_media
-
-XPIDLSRCS = \
-  nsIDOMMediaStream.idl \
-  $(NULL)
 
 EXPORTS = \
   AudioSegment.h \
   FileBlockCache.h \
   MediaEngine.h \
   MediaEngineDefault.h \
   MediaResource.h \
   MediaSegment.h \
diff --git a/content/media/MediaEngineDefault.cpp b/content/media/MediaEngineDefault.cpp
--- a/content/media/MediaEngineDefault.cpp
+++ b/content/media/MediaEngineDefault.cpp
@@ -74,26 +74,26 @@ MediaEngineDefaultVideoSource::Start(Sou
     return NS_ERROR_FAILURE;
   }
 
   mSource = aStream;
 
   // Allocate a single blank Image
   layers::Image::Format format = layers::Image::PLANAR_YCBCR;
   mImageContainer = layers::LayerManager::CreateImageContainer();
-    
+
   nsRefPtr<layers::Image> image = mImageContainer->CreateImage(&format, 1);
-  
+
   int len = ((WIDTH * HEIGHT) * 3 / 2);
   mImage = static_cast<layers::PlanarYCbCrImage*>(image.get());
   PRUint8* frame = (PRUint8*) PR_Malloc(len);
   memset(frame, 0x80, len); // Gray
 
   const PRUint8 lumaBpp = 8;
-  const PRUint8 chromaBpp = 4; 
+  const PRUint8 chromaBpp = 4;
 
   layers::PlanarYCbCrImage::Data data;
   data.mYChannel = frame;
   data.mYSize = gfxIntSize(WIDTH, HEIGHT);
   data.mYStride = WIDTH * lumaBpp / 8.0;
   data.mCbCrStride = WIDTH * chromaBpp / 8.0;
   data.mCbChannel = frame + HEIGHT * data.mYStride;
   data.mCrChannel = data.mCbChannel + HEIGHT * data.mCbCrStride / 2;
@@ -117,17 +117,17 @@ MediaEngineDefaultVideoSource::Start(Sou
   mSource->AdvanceKnownTracksTime(STREAM_TIME_MAX);
 
   // Remember TrackID so we can end it later
   mTrackID = aID;
 
   // Start timer for subsequent frames
   mTimer->InitWithCallback(this, 1000 / FPS, nsITimer::TYPE_REPEATING_SLACK);
   mState = kStarted;
-  
+
   return NS_OK;
 }
 
 nsresult
 MediaEngineDefaultVideoSource::Stop()
 {
   if (mState != kStarted) {
     return NS_ERROR_FAILURE;
@@ -222,17 +222,17 @@ MediaEngineDefaultAudioSource::Start(Sou
   segment->Init(CHANNELS);
   mSource->AddTrack(aID, RATE, 0, segment);
 
   // We aren't going to add any more tracks
   mSource->AdvanceKnownTracksTime(STREAM_TIME_MAX);
 
   // Remember TrackID so we can finish later
   mTrackID = aID;
-  
+
   // 1 Audio frame per Video frame
   mTimer->InitWithCallback(this, 1000 / FPS, nsITimer::TYPE_REPEATING_SLACK);
   mState = kStarted;
 
   return NS_OK;
 }
 
 nsresult
@@ -280,9 +280,9 @@ MediaEngineDefault::EnumerateVideoDevice
 }
 
 void
 MediaEngineDefault::EnumerateAudioDevices(nsTArray<nsRefPtr<MediaEngineAudioSource> >* aASources) {
   aASources->AppendElement(mASource);
   return;
 }
 
-}
+} // namespace mozilla
diff --git a/dom/Makefile.in b/dom/Makefile.in
--- a/dom/Makefile.in
+++ b/dom/Makefile.in
@@ -45,16 +45,17 @@ DIRS += \
 
 DIRS += \
   apps \
   base \
   bindings \
   battery \
   contacts \
   devicestorage \
+  media \
   power \
   settings \
   sms \
   src \
   locales \
   network \
   plugins/base \
   plugins/ipc \
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -33,16 +33,19 @@
 #include "SmsManager.h"
 #include "nsISmsService.h"
 #include "mozilla/Hal.h"
 #include "nsIWebNavigation.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "Connection.h"
 #include "MobileConnection.h"
 
+#ifdef MOZ_MEDIA_NAVIGATOR
+#include "MediaManager.h"
+#endif
 #ifdef MOZ_B2G_RIL
 #include "TelephonyFactory.h"
 #endif
 #ifdef MOZ_B2G_BT
 #include "nsIDOMBluetoothManager.h"
 #include "BluetoothManager.h"
 #endif
 
@@ -90,16 +93,19 @@ NS_INTERFACE_MAP_BEGIN(Navigator)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMClientInformation)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorDeviceStorage)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorGeolocation)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMozNavigatorBattery)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorDesktopNotification)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMozNavigatorSms)
+#ifdef MOZ_MEDIA_NAVIGATOR
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorUserMedia)
+#endif
 #ifdef MOZ_B2G_RIL
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorTelephony)
 #endif
   NS_INTERFACE_MAP_ENTRY(nsIDOMMozNavigatorNetwork)
 #ifdef MOZ_B2G_BT
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorBluetooth)
 #endif
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Navigator)
@@ -895,16 +901,35 @@ NS_IMETHODIMP Navigator::GetGeolocation(
     return NS_ERROR_FAILURE;
   }
 
   NS_ADDREF(*_retval = mGeolocation);
   return NS_OK;
 }
 
 //*****************************************************************************
+//    Navigator::nsIDOMNavigatorUserMedia (mozGetUserMedia)
+//*****************************************************************************
+#ifdef MOZ_MEDIA_NAVIGATOR
+NS_IMETHODIMP
+Navigator::MozGetUserMedia(nsIMediaStreamOptions* aParams,
+                           nsIDOMGetUserMediaSuccessCallback* onSuccess,
+                           nsIDOMGetUserMediaErrorCallback* onError)
+{
+  if (!Preferences::GetBool("media.navigator.enabled", false)) {
+    return NS_OK;
+  }
+
+  media::MediaManager *manager = media::MediaManager::Get();
+  nsCOMPtr<nsPIDOMWindow> win = do_QueryReferent(mWindow);
+  return manager->GetUserMedia(win->WindowID(), aParams, onSuccess, onError);
+}
+#endif
+
+//*****************************************************************************
 //    Navigator::nsIDOMNavigatorDesktopNotification
 //*****************************************************************************
 
 NS_IMETHODIMP Navigator::GetMozNotification(nsIDOMDesktopNotificationCenter** aRetVal)
 {
   NS_ENSURE_ARG_POINTER(aRetVal);
   *aRetVal = nsnull;
 
@@ -1196,16 +1221,27 @@ Navigator::SizeOfIncludingThis(nsMallocS
 void
 Navigator::SetWindow(nsPIDOMWindow *aInnerWindow)
 {
   NS_ASSERTION(aInnerWindow->IsInnerWindow(),
                "Navigator must get an inner window!");
   mWindow = do_GetWeakReference(aInnerWindow);
 }
 
+void
+Navigator::OnNavigation()
+{
+  // Inform MediaManager in case there are live streams or pending callbacks.
+#ifdef MOZ_MEDIA_NAVIGATOR
+  media::MediaManager *manager = media::MediaManager::Get();
+  nsCOMPtr<nsPIDOMWindow> win = do_QueryReferent(mWindow);
+  return manager->OnNavigation(win->WindowID());
+#endif
+}
+
 } // namespace dom
 } // namespace mozilla
 
 nsresult
 NS_GetNavigatorUserAgent(nsAString& aUserAgent)
 {
   nsresult rv;
 
diff --git a/dom/base/Navigator.h b/dom/base/Navigator.h
--- a/dom/base/Navigator.h
+++ b/dom/base/Navigator.h
@@ -20,16 +20,20 @@
 
 class nsPluginArray;
 class nsMimeTypeArray;
 class nsGeolocation;
 class nsDesktopNotificationCenter;
 class nsPIDOMWindow;
 class nsIDOMMozConnection;
 
+#ifdef MOZ_MEDIA_NAVIGATOR
+#include "nsIDOMNavigatorUserMedia.h"
+#endif
+
 #ifdef MOZ_B2G_RIL
 #include "nsIDOMNavigatorTelephony.h"
 class nsIDOMTelephony;
 #endif
 
 #ifdef MOZ_B2G_BT
 #include "nsIDOMNavigatorBluetooth.h"
 #endif
@@ -60,36 +64,43 @@ class PowerManager;
 
 class Navigator : public nsIDOMNavigator
                 , public nsIDOMClientInformation
                 , public nsIDOMNavigatorDeviceStorage
                 , public nsIDOMNavigatorGeolocation
                 , public nsIDOMNavigatorDesktopNotification
                 , public nsIDOMMozNavigatorBattery
                 , public nsIDOMMozNavigatorSms
+#ifdef MOZ_MEDIA_NAVIGATOR
+                , public nsIDOMNavigatorUserMedia
+#endif
 #ifdef MOZ_B2G_RIL
                 , public nsIDOMNavigatorTelephony
 #endif
                 , public nsIDOMMozNavigatorNetwork
 #ifdef MOZ_B2G_BT
                 , public nsIDOMNavigatorBluetooth
 #endif
+
 {
 public:
   Navigator(nsPIDOMWindow *aInnerWindow);
   virtual ~Navigator();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMNAVIGATOR
   NS_DECL_NSIDOMCLIENTINFORMATION
   NS_DECL_NSIDOMNAVIGATORDEVICESTORAGE
   NS_DECL_NSIDOMNAVIGATORGEOLOCATION
   NS_DECL_NSIDOMNAVIGATORDESKTOPNOTIFICATION
   NS_DECL_NSIDOMMOZNAVIGATORBATTERY
   NS_DECL_NSIDOMMOZNAVIGATORSMS
+#ifdef MOZ_MEDIA_NAVIGATOR
+  NS_DECL_NSIDOMNAVIGATORUSERMEDIA
+#endif
 #ifdef MOZ_B2G_RIL
   NS_DECL_NSIDOMNAVIGATORTELEPHONY
 #endif
   NS_DECL_NSIDOMMOZNAVIGATORNETWORK
 
 #ifdef MOZ_B2G_BT
   NS_DECL_NSIDOMNAVIGATORBLUETOOTH
 #endif
@@ -105,16 +116,21 @@ public:
 
   size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 
   /**
    * For use during document.write where our inner window changes.
    */
   void SetWindow(nsPIDOMWindow *aInnerWindow);
 
+  /**
+   * Called when the inner window navigates to a new page.
+   */
+  void OnNavigation();
+
 private:
   bool IsSmsAllowed() const;
   bool IsSmsSupported() const;
 
   nsRefPtr<nsMimeTypeArray> mMimeTypes;
   nsRefPtr<nsPluginArray> mPlugins;
   nsRefPtr<nsGeolocation> mGeolocation;
   nsRefPtr<nsDesktopNotificationCenter> mNotification;
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -422,16 +422,19 @@
 #include "nsIDOMDataTransfer.h"
 
 // Geolocation
 #include "nsIDOMGeoGeolocation.h"
 #include "nsIDOMGeoPosition.h"
 #include "nsIDOMGeoPositionCoords.h"
 #include "nsIDOMGeoPositionError.h"
 
+// User media
+#include "nsIDOMNavigatorUserMedia.h"
+
 // Workers
 #include "mozilla/dom/workers/Workers.h"
 
 #include "nsDOMFile.h"
 #include "nsDOMFileReader.h"
 #include "nsIDOMFormData.h"
 
 #include "nsIDOMDOMStringMap.h"
@@ -2444,16 +2447,17 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_BEGIN(Location, nsIDOMLocation)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMLocation)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Navigator, nsIDOMNavigator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigatorDeviceStorage)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigatorGeolocation)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigatorUserMedia)
     DOM_CLASSINFO_MAP_CONDITIONAL_ENTRY(nsIDOMNavigatorDesktopNotification,
                                         Navigator::HasDesktopNotificationSupport())
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMClientInformation)
     DOM_CLASSINFO_MAP_CONDITIONAL_ENTRY(nsIDOMMozNavigatorBattery,
                                         battery::BatteryManager::HasSupport())
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMMozNavigatorSms)
 #ifdef MOZ_B2G_RIL
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigatorTelephony)
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1078,16 +1078,17 @@ nsGlobalWindow::FreeInnerObjects()
     mListenerManager->Disconnect();
     mListenerManager = nsnull;
   }
 
   mLocation = nsnull;
   mHistory = nsnull;
 
   if (mNavigator) {
+    mNavigator->OnNavigation();
     mNavigator->Invalidate();
     mNavigator = nsnull;
   }
 
   if (mScreen) {
     mScreen = nsnull;
   }
 
@@ -1743,16 +1744,20 @@ nsGlobalWindow::SetNewDocument(nsIDocume
 #ifdef DEBUG
   mLastOpenedURI = aDocument->GetDocumentURI();
 #endif
 
   mContext->WillInitializeContext();
 
   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
 
+  if (currentInner && currentInner->mNavigator) {
+    currentInner->mNavigator->OnNavigation();
+  }
+
   nsRefPtr<nsGlobalWindow> newInnerWindow;
   bool createdInnerWindow = false;
 
   bool thisChrome = IsChromeWindow();
 
   bool isChrome = false;
 
   nsCxPusher cxPusher;
diff --git a/dom/dom-config.mk b/dom/dom-config.mk
--- a/dom/dom-config.mk
+++ b/dom/dom-config.mk
@@ -1,16 +1,17 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DOM_SRCDIRS = \
   dom/base \
   dom/battery \
   dom/power \
+  dom/media \
   dom/network/src \
   dom/settings \
   dom/sms/src \
   dom/contacts \
   dom/src/events \
   dom/src/storage \
   dom/src/offline \
   dom/src/geolocation \
diff --git a/dom/media/Makefile.in b/dom/media/Makefile.in
new file mode 100644
--- /dev/null
+++ b/dom/media/Makefile.in
@@ -0,0 +1,39 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH            = ../..
+topsrcdir        = @top_srcdir@
+srcdir           = @srcdir@
+VPATH            = @srcdir@
+
+relativesrcdir   = dom/media
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE           = dom
+XPIDL_MODULE     = dom_media
+LIBRARY_NAME     = dom_media_s
+LIBXUL_LIBRARY   = 1
+FORCE_STATIC_LIB = 1
+
+include $(topsrcdir)/dom/dom-config.mk
+
+XPIDLSRCS = \
+  nsIDOMMediaStream.idl \
+  nsIDOMNavigatorUserMedia.idl \
+  $(NULL)
+
+#EXPORTS_NAMESPACE = mozilla/dom
+
+#EXPORTS_mozilla/dom = \
+EXPORTS = \
+  MediaManager.h \
+  $(NULL)
+
+CPPSRCS = \
+  MediaManager.cpp \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/config/rules.mk
diff --git a/dom/media/MediaManager.cpp b/dom/media/MediaManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/media/MediaManager.cpp
@@ -0,0 +1,516 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "MediaManager.h"
+
+#include "MediaStreamGraph.h"
+#include "MediaEngineDefault.h"
+
+#include "nsIDOMFile.h"
+#include "nsIScriptGlobalObject.h"
+
+#include "nsJSUtils.h"
+#include "nsDOMFile.h"
+
+namespace mozilla {
+namespace dom {
+namespace media {
+
+/**
+ * Send an error back to content. The error is the form a string.
+ * Do this only on the main thread.
+ */
+class ErrorCallbackRunnable : public CallbackRunnable
+{
+public:
+  ErrorCallbackRunnable(nsIDOMGetUserMediaErrorCallback* aError,
+    const nsString& aErrorMsg)
+    : mError(aError)
+    , mErrorMsg(aErrorMsg)
+    , mValid(true) {}
+
+  NS_IMETHOD
+  Run()
+  {
+    if (!mValid) {
+      return NS_OK;
+    }
+    mError->OnError(mErrorMsg);
+    return NS_OK;
+  }
+
+  void
+  Invalidate()
+  {
+    mValid = false;
+  }
+
+private:
+  nsCOMPtr<nsIDOMGetUserMediaErrorCallback> mError;
+  const nsString mErrorMsg;
+  bool mValid;
+};
+
+/**
+ * Invoke the "onSuccess" callback in content. The callback will take a
+ * DOMBlob in the case of {picture:true}, and a MediaStream in the case of
+ * {audio:true} or {video:true}. There is a constructor available for each
+ * form. Do this only on the main thread.
+ */
+class SuccessCallbackRunnable : public CallbackRunnable
+{
+public:
+  SuccessCallbackRunnable(nsIDOMGetUserMediaSuccessCallback* aSuccess,
+    nsIDOMFile* aFile)
+    : mSuccess(aSuccess)
+    , mFile(aFile)
+    , mValid(true) {}
+
+  SuccessCallbackRunnable(nsIDOMGetUserMediaSuccessCallback* aSuccess,
+    nsIDOMMediaStream* aStream)
+    : mSuccess(aSuccess)
+    , mStream(aStream)
+    , mValid(true) {}
+
+  NS_IMETHOD
+  Run()
+  {
+    if (!mValid) {
+      return NS_OK;
+    }
+
+    // XPConnect is a magical unicorn.
+    if (mFile) {
+      mSuccess->OnSuccess(mFile);
+    } else if (mStream) {
+      mSuccess->OnSuccess(mStream);
+    }
+
+    return NS_OK;
+  }
+
+  void
+  Invalidate()
+  {
+    mValid = false;
+  }
+
+private:
+  nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccess;
+  nsCOMPtr<nsIDOMFile> mFile;
+  nsCOMPtr<nsIDOMMediaStream> mStream;
+  bool mValid;
+};
+
+/**
+ * This runnable creates a nsDOMMediaStream from a given MediaEngineSource
+ * and returns it via a success callback. Both must be done on the main thread.
+ */
+class GetUserMediaCallbackRunnable : public nsRunnable
+{
+public:
+  GetUserMediaCallbackRunnable(MediaEngineSource* aSource, TrackID aId,
+    nsIDOMGetUserMediaSuccessCallback* aSuccess,
+    nsIDOMGetUserMediaErrorCallback* aError,
+    CallbackRunnables* aRunnables)
+    : mSource(aSource)
+    , mId(aId)
+    , mSuccess(aSuccess)
+    , mError(aError)
+    , mRunnables(aRunnables) {}
+
+  /**
+   * This inner class is an implementation of MediaStreamListener. This is used
+   * to Start() and Stop() the underlying MediaEngineSource when MediaStreams
+   * are assigned and deassigned in content.
+   */
+  class GetUserMediaCallbackMediaStreamListener : public MediaStreamListener,
+                                                  public CallbackRunnable
+  {
+  public:
+    GetUserMediaCallbackMediaStreamListener(MediaEngineSource* aSource,
+      nsDOMMediaStream* aStream, TrackID aListenId)
+      : mSource(aSource)
+      , mStream(aStream)
+      , mId(aListenId)
+      , mValid(true) {}
+
+    void
+    Invalidate()
+    {
+      if (!mValid) {
+        return;
+      }
+      mValid = false;
+      mSource->Stop();
+      mSource->Deallocate();
+    }
+
+    void
+    NotifyConsumptionChanged(MediaStreamGraph* aGraph, Consumption aConsuming)
+    {
+      if (!mValid) {
+        return;
+      }
+
+      if (aConsuming == CONSUMED) {
+        nsRefPtr<SourceMediaStream> stream = mStream->GetStream()->AsSourceStream();
+        mSource->Start(stream, mId);
+        return;
+      }
+
+      // NOT_CONSUMED
+      Invalidate();
+      return;
+    }
+
+    void NotifyBlockingChanged(MediaStreamGraph* aGraph, Blocking aBlocked) {}
+    void NotifyOutput(MediaStreamGraph* aGraph) {}
+    void NotifyFinished(MediaStreamGraph* aGraph) {}
+    void NotifyQueuedTrackChanges(MediaStreamGraph* aGraph, TrackID aID,
+      TrackRate aTrackRate, TrackTicks aTrackOffset,
+      PRUint32 aTrackEvents, const MediaSegment& aQueuedMedia) {}
+    nsresult Run() { return NS_OK; }
+
+  private:
+    nsCOMPtr<MediaEngineSource> mSource;
+    nsCOMPtr<nsDOMMediaStream> mStream;
+    TrackID mId;
+    bool mValid;
+  };
+
+  NS_IMETHOD
+  Run()
+  {
+    /**
+     * Normally we would now get the name & UUID for the device and ask the
+     * user permission. We will do that when we have some UI. Currently,
+     * only the Android {picture:true} backend is functional, which does not
+     * need a permission prompt, as permission is implicit by user action.
+     *
+     * See bug 748835 for progress on the desktop UI.
+     */
+    nsCOMPtr<nsDOMMediaStream> comStream = mSource->Allocate();
+    if (!comStream) {
+      ErrorCallbackRunnable* ecr = new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE")
+      );
+      mRunnables->AppendElement(ecr);
+      NS_DispatchToMainThread(ecr);
+      return NS_OK;
+    }
+
+    // Add our listener. We'll call Start() on the source when get a callback
+    // that the MediaStream has started consuming.
+    GetUserMediaCallbackMediaStreamListener* listener =
+      new GetUserMediaCallbackMediaStreamListener(mSource, comStream, mId);
+    comStream->GetStream()->AddListener(listener);
+
+    // Add the listener to CallbackRunnables so it can be invalidated.
+    mRunnables->AppendElement(listener);
+
+    SuccessCallbackRunnable* scr = new SuccessCallbackRunnable(
+      mSuccess, comStream.get()
+    );
+    mRunnables->AppendElement(scr);
+    NS_DispatchToMainThread(scr);
+    return NS_OK;
+  }
+
+private:
+  nsCOMPtr<MediaEngineSource> mSource;
+  TrackID mId;
+  nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccess;
+  nsCOMPtr<nsIDOMGetUserMediaErrorCallback> mError;
+  CallbackRunnables* mRunnables;
+};
+
+/**
+ * This runnable creates a nsIDOMFile from a MediaEngineVideoSource and
+ * passes the result back via a SuccessRunnable. Both must be done on the
+ * main thread.
+ */
+class GetUserMediaSnapshotCallbackRunable : public nsRunnable
+{
+public:
+  GetUserMediaSnapshotCallbackRunable(MediaEngineSource* aSource,
+    PRUint32 aDuration,
+    nsIDOMGetUserMediaSuccessCallback* aSuccessCallback,
+    nsIDOMGetUserMediaErrorCallback* aErrorCallback,
+    CallbackRunnables* aRunnables)
+    : mSource(aSource)
+    , mDuration(aDuration)
+    , mSuccessCallback(aSuccessCallback)
+    , mErrorCallback(aErrorCallback)
+    , mRunnables(aRunnables) {}
+
+  NS_IMETHOD
+  Run()
+  {
+    nsCOMPtr<nsDOMMediaStream> comStream = mSource->Allocate();
+    if (!comStream) {
+      ErrorCallbackRunnable* ecr = new ErrorCallbackRunnable(
+        mErrorCallback, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE")
+      );
+      mRunnables->AppendElement(ecr);
+      NS_DispatchToMainThread(ecr);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIDOMFile> file;
+    mSource->Snapshot(mDuration, getter_AddRefs(file));
+    mSource->Deallocate();
+
+    SuccessCallbackRunnable* scr = new SuccessCallbackRunnable(
+      mSuccessCallback, file
+    );
+    mRunnables->AppendElement(scr);
+    NS_DispatchToMainThread(scr);
+    return NS_OK;
+  }
+
+private:
+  nsCOMPtr<MediaEngineSource> mSource;
+  PRUint32 mDuration;
+  nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccessCallback;
+  nsCOMPtr<nsIDOMGetUserMediaErrorCallback>  mErrorCallback;
+  CallbackRunnables* mRunnables;
+};
+
+/**
+ * Runs on a seperate thread and is responsible for enumerating devices.
+ * Depending on whether a picture or stream was asked for, either
+ * GetUserMediaCallbackRunnable or GetUserMediaSnapshotCallbackRunnable
+ * will be dispatched to the main thread to return the result to DOM.
+ *
+ * Do not run this on the main thread.
+ */
+class GetUserMediaRunnable : public nsRunnable
+{
+public:
+  GetUserMediaRunnable(bool aAudio, bool aVideo, bool aPicture,
+    MediaManager* aManager,
+    nsIDOMGetUserMediaSuccessCallback* aSuccess,
+    nsIDOMGetUserMediaErrorCallback* aError,
+    CallbackRunnables* aRunnables)
+    : mAudio(aAudio)
+    , mVideo(aVideo)
+    , mPicture(aPicture)
+    , mManager(aManager)
+    , mSuccess(aSuccess)
+    , mError(aError)
+    , mRunnables(aRunnables) {}
+
+  ~GetUserMediaRunnable() {}
+
+  // We only support 1 audio and 1 video track for now.
+  enum {
+    kVideoTrack = 1,
+    kAudioTrack = 2
+  };
+
+  NS_IMETHOD
+  Run()
+  {
+    if (mPicture) {
+      SendPicture();
+      return NS_OK;
+    }
+
+    // XXX: Implement merging two streams (See bug 758391).
+    if (mAudio && mVideo) {
+      ErrorCallbackRunnable* ecr = new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("NOT_IMPLEMENTED")
+      );
+      mRunnables->AppendElement(ecr);
+      NS_DispatchToMainThread(ecr);
+      return NS_OK;
+    }
+
+    if (mVideo) {
+      SendVideo();
+      return NS_OK;
+    }
+
+    if (mAudio) {
+      SendAudio();
+      return NS_OK;
+    }
+
+    return NS_OK;
+  }
+
+  // {picture:true}
+  void
+  SendPicture()
+  {
+    nsTArray<nsRefPtr<MediaEngineVideoSource> > videoSources;
+    mManager->GetBackend()->EnumerateVideoDevices(&videoSources);
+
+    PRUint32 count = videoSources.Length();
+    if (!count) {
+      ErrorCallbackRunnable* ecr = new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("NO_DEVICES_FOUND")
+      );
+      mRunnables->AppendElement(ecr);
+      NS_DispatchToMainThread(ecr);
+    }
+    MediaEngineVideoSource* videoSource = videoSources[count - 1];
+    NS_DispatchToMainThread(new GetUserMediaSnapshotCallbackRunable(
+      videoSource, 0 /* duration */, mSuccess, mError, mRunnables
+    ));
+  }
+
+  // {video:true}
+  void
+  SendVideo()
+  {
+    nsTArray<nsRefPtr<MediaEngineVideoSource> > videoSources;
+    mManager->GetBackend()->EnumerateVideoDevices(&videoSources);
+
+    PRUint32 count = videoSources.Length();
+    if (!count) {
+      ErrorCallbackRunnable* ecr = new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("NO_DEVICES_FOUND")
+      );
+      mRunnables->AppendElement(ecr);
+      NS_DispatchToMainThread(ecr);
+    }
+
+    MediaEngineVideoSource* videoSource = videoSources[count - 1];
+    NS_DispatchToMainThread(new GetUserMediaCallbackRunnable(
+      videoSource, kVideoTrack, mSuccess, mError, mRunnables
+    ));
+  }
+
+  // {audio:true}
+  void
+  SendAudio()
+  {
+    nsTArray<nsRefPtr<MediaEngineAudioSource> > audioSources;
+    mManager->GetBackend()->EnumerateAudioDevices(&audioSources);
+
+    PRUint32 count = audioSources.Length();
+    if (!count) {
+      ErrorCallbackRunnable* ecr = new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("NO_DEVICES_FOUND")
+      );
+      mRunnables->AppendElement(ecr);
+      NS_DispatchToMainThread(ecr);
+    }
+
+    MediaEngineAudioSource* audioSource = audioSources[count - 1];
+    NS_DispatchToMainThread(new GetUserMediaCallbackRunnable(
+      audioSource, kAudioTrack, mSuccess, mError, mRunnables
+    ));
+  }
+
+private:
+  bool mAudio;
+  bool mVideo;
+  bool mPicture;
+
+  MediaManager* mManager;
+  nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccess;
+  nsCOMPtr<nsIDOMGetUserMediaErrorCallback> mError;
+  CallbackRunnables* mRunnables;
+};
+
+
+MediaManager* MediaManager::mSingleton;
+
+NS_IMPL_ISUPPORTS1(MediaManager, nsIObserver)
+
+/**
+ * The entry point for this file. A call from Navigator::mozGetUserMedia
+ * will end up here. MediaManager is a singleton that is responsible
+ * for handling all incoming getUserMedia calls from every window.
+ */
+nsresult
+MediaManager::GetUserMedia(PRUint64 aWindowID, nsIMediaStreamOptions* aParams,
+  nsIDOMGetUserMediaSuccessCallback* onSuccess,
+  nsIDOMGetUserMediaErrorCallback* onError)
+{
+  NS_ENSURE_TRUE(aParams, NS_ERROR_NULL_POINTER);
+
+  bool audio, video, picture;
+  nsresult rv = aParams->GetPicture(&picture);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = aParams->GetAudio(&audio);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = aParams->GetVideo(&video);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // We only support "front" or "back". TBD: Send to GetUserMediaRunnable.
+  nsString cameraType;
+  rv = aParams->GetCamera(cameraType);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Store the WindowID in a hash table so we can cancel runnables and release
+  // MediaStreams, if any, when a window is closed or navigation occurs.
+  CallbackRunnables* runnables = new CallbackRunnables();
+  mRunnables.Put(aWindowID, runnables);
+
+  // Pass runanbles along to GetUserMediaRunnable so it can add the
+  // MediaStreamListener to the runnable list
+  nsCOMPtr<nsIRunnable> gUMRunnable = new GetUserMediaRunnable(
+    audio, video, picture, this, onSuccess, onError, runnables
+  );
+
+  nsCOMPtr<nsIThread> gUMThread;
+  rv = NS_NewThread(getter_AddRefs(gUMThread), gUMRunnable);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+MediaEngine*
+MediaManager::GetBackend()
+{
+  // Plugin backends as appropriate. Only default is available for now, which
+  // also includes picture support for Android.
+  if (!mBackend) {
+    mBackend = new MediaEngineDefault();
+  }
+  return mBackend;
+}
+
+void
+MediaManager::OnNavigation(PRUint64 aWindowID)
+{
+  // Invalidate all the runnables associated with this window.
+  CallbackRunnables* runnables = mRunnables.Get(aWindowID);
+  if (!runnables) {
+    return;
+  }
+
+  PRUint32 length = runnables->Length();
+  for (PRUint32 i = 0; i < length; i++) {
+    CallbackRunnable* runnable = runnables->SafeElementAt(i);
+    if (runnable) {
+      runnable->Invalidate();
+    }
+  }
+}
+
+nsresult
+MediaManager::Observe(nsISupports* aSubject, const char* aTopic,
+  const PRUnichar* aData)
+{
+  if (strcmp(aTopic, "xpcom-shutdown")) {
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  obs->RemoveObserver(this, "xpcom-shutdown");
+
+  delete mSingleton;
+  return NS_OK;
+}
+
+} // namespace mozilla
+} // namespace dom
+} // namespace media
diff --git a/dom/media/MediaManager.h b/dom/media/MediaManager.h
new file mode 100644
--- /dev/null
+++ b/dom/media/MediaManager.h
@@ -0,0 +1,64 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "MediaEngine.h"
+#include "mozilla/Services.h"
+
+#include "nsHashKeys.h"
+#include "nsClassHashtable.h"
+#include "nsObserverService.h"
+
+#include "nsIDOMNavigatorUserMedia.h"
+
+namespace mozilla {
+namespace dom {
+namespace media {
+
+class CallbackRunnable : public nsRunnable {
+public:
+  CallbackRunnable() {};
+  virtual ~CallbackRunnable() {};
+
+  virtual nsresult Run() = 0;
+  virtual void Invalidate() = 0;
+};
+
+typedef nsTArray<nsRefPtr<CallbackRunnable> > CallbackRunnables;
+
+class MediaManager : public nsIObserver {
+public:
+  static MediaManager* Get() {
+    if (!mSingleton) {
+      mSingleton = new MediaManager();
+
+      nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
+      obs->AddObserver(mSingleton, "xpcom-shutdown", false);
+    }
+    return mSingleton;
+  }
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIOBSERVER
+
+  MediaEngine* GetBackend();
+  nsresult GetUserMedia(PRUint64 aWindowID, nsIMediaStreamOptions* aParams,
+    nsIDOMGetUserMediaSuccessCallback* onSuccess,
+    nsIDOMGetUserMediaErrorCallback* onError);
+  void OnNavigation(PRUint64 aWindowID);
+
+private:
+  // Make private because we want only one instance of this class
+  MediaManager() : mBackend(nsnull) {mRunnables.Init(); };
+  MediaManager(MediaManager const&) {};
+
+  ~MediaManager() { delete mBackend; };
+
+  MediaEngine* mBackend;
+  static MediaManager* mSingleton;
+  nsClassHashtable<nsUint64HashKey, CallbackRunnables > mRunnables;
+};
+
+} // namespace mozilla
+} // namespace dom
+} // namespace media
diff --git a/content/media/nsIDOMMediaStream.idl b/dom/media/nsIDOMMediaStream.idl
rename from content/media/nsIDOMMediaStream.idl
rename to dom/media/nsIDOMMediaStream.idl
diff --git a/dom/media/nsIDOMNavigatorUserMedia.idl b/dom/media/nsIDOMNavigatorUserMedia.idl
new file mode 100644
--- /dev/null
+++ b/dom/media/nsIDOMNavigatorUserMedia.idl
@@ -0,0 +1,39 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+#include "nsIDOMMediaStream.idl"
+
+[scriptable, function, uuid(f2a144fc-3534-4761-8c5d-989ae720f89a)]
+interface nsIDOMGetUserMediaSuccessCallback : nsISupports
+{
+  /*
+   * value must be a nsIDOMBlob if picture is true and a
+   * nsIDOMMediaStream if either audio or video are true.
+   */
+  void onSuccess(in nsISupports value);
+};
+
+[scriptable, function, uuid(2614bbcf-85cc-43e5-8740-964f52bdc7ca)]
+interface nsIDOMGetUserMediaErrorCallback : nsISupports
+{
+  void onError(in DOMString error);
+};
+
+[scriptable, uuid(8a26205e-e8f7-4372-bd15-97ff982b4c1c)]
+interface nsIMediaStreamOptions : nsISupports
+{
+  readonly attribute boolean audio;
+  readonly attribute boolean video;
+  readonly attribute boolean picture;
+  readonly attribute DOMString camera;
+};
+
+[scriptable, uuid(381e0071-0be5-4f6b-ae21-8e3407a37faa)]
+interface nsIDOMNavigatorUserMedia : nsISupports
+{
+  void mozGetUserMedia(in nsIMediaStreamOptions params,
+		       in nsIDOMGetUserMediaSuccessCallback onsuccess,
+		       in nsIDOMGetUserMediaErrorCallback onerror);
+};
diff --git a/layout/build/Makefile.in b/layout/build/Makefile.in
--- a/layout/build/Makefile.in
+++ b/layout/build/Makefile.in
@@ -61,16 +61,17 @@ SHARED_LIBRARY_LIBS = \
 	$(DEPTH)/view/src/$(LIB_PREFIX)gkview_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/base/$(LIB_PREFIX)jsdombase_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/battery/$(LIB_PREFIX)dom_battery_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/contacts/$(LIB_PREFIX)jsdomcontacts_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/devicestorage/$(LIB_PREFIX)domdevicestorage_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/power/$(LIB_PREFIX)dom_power_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/settings/$(LIB_PREFIX)jsdomsettings_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/network/src/$(LIB_PREFIX)dom_network_s.$(LIB_SUFFIX) \
+	$(DEPTH)/dom/media/$(LIB_PREFIX)dom_media_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/sms/src/$(LIB_PREFIX)dom_sms_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/events/$(LIB_PREFIX)jsdomevents_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/json/$(LIB_PREFIX)json_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/jsurl/$(LIB_PREFIX)jsurl_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/storage/$(LIB_PREFIX)jsdomstorage_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/offline/$(LIB_PREFIX)jsdomoffline_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/geolocation/$(LIB_PREFIX)jsdomgeolocation_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/notification/$(LIB_PREFIX)jsdomnotification_s.$(LIB_SUFFIX) \
diff --git a/mobile/android/installer/package-manifest.in b/mobile/android/installer/package-manifest.in
--- a/mobile/android/installer/package-manifest.in
+++ b/mobile/android/installer/package-manifest.in
@@ -143,31 +143,31 @@
 @BINPATH@/components/commandhandler.xpt
 @BINPATH@/components/commandlines.xpt
 @BINPATH@/components/composer.xpt
 @BINPATH@/components/content_base.xpt
 @BINPATH@/components/content_events.xpt
 @BINPATH@/components/content_canvas.xpt
 @BINPATH@/components/content_htmldoc.xpt
 @BINPATH@/components/content_html.xpt
-@BINPATH@/components/content_media.xpt
 @BINPATH@/components/content_xslt.xpt
 @BINPATH@/components/content_xtf.xpt
 @BINPATH@/components/cookie.xpt
 @BINPATH@/components/directory.xpt
 @BINPATH@/components/docshell.xpt
 @BINPATH@/components/dom.xpt
 @BINPATH@/components/dom_apps.xpt
 @BINPATH@/components/dom_base.xpt
 @BINPATH@/components/dom_battery.xpt
 @BINPATH@/components/dom_canvas.xpt
 @BINPATH@/components/dom_core.xpt
 @BINPATH@/components/dom_css.xpt
 @BINPATH@/components/dom_events.xpt
 @BINPATH@/components/dom_geolocation.xpt
+@BINPATH@/components/dom_media.xpt
 @BINPATH@/components/dom_network.xpt
 @BINPATH@/components/dom_notification.xpt
 @BINPATH@/components/dom_html.xpt
 @BINPATH@/components/dom_indexeddb.xpt
 @BINPATH@/components/dom_offline.xpt
 @BINPATH@/components/dom_json.xpt
 @BINPATH@/components/dom_range.xpt
 @BINPATH@/components/dom_sidebar.xpt
diff --git a/mobile/xul/installer/package-manifest.in b/mobile/xul/installer/package-manifest.in
--- a/mobile/xul/installer/package-manifest.in
+++ b/mobile/xul/installer/package-manifest.in
@@ -1,13 +1,13 @@
 ; This Source Code Form is subject to the terms of the Mozilla Public
 ; License, v. 2.0. If a copy of the MPL was not distributed with this
 ; file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-; Package file for the Fennec build. 
+; Package file for the Fennec build.
 ;
 ; File format:
 ;
 ; [] designates a toplevel component. Example: [xpcom]
 ; - in front of a file specifies it to be removed from the destination
 ; * wildcard support to recursively copy the entire directory
 ; ; file comment
 ;
@@ -143,17 +143,16 @@
 @BINPATH@/components/commandhandler.xpt
 @BINPATH@/components/commandlines.xpt
 @BINPATH@/components/composer.xpt
 @BINPATH@/components/content_base.xpt
 @BINPATH@/components/content_events.xpt
 @BINPATH@/components/content_canvas.xpt
 @BINPATH@/components/content_htmldoc.xpt
 @BINPATH@/components/content_html.xpt
-@BINPATH@/components/content_media.xpt
 @BINPATH@/components/content_xslt.xpt
 @BINPATH@/components/content_xtf.xpt
 @BINPATH@/components/cookie.xpt
 @BINPATH@/components/directory.xpt
 @BINPATH@/components/docshell.xpt
 @BINPATH@/components/dom.xpt
 @BINPATH@/components/dom_base.xpt
 #ifdef MOZ_B2G_RIL
