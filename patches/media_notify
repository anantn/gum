# HG changeset patch
# Parent b2932bffb761ac1071a7522732086c70336b2e90
# User Robert O'Callahan <robert@ocallahan.org>
diff --git a/content/media/MediaStreamGraph.cpp b/content/media/MediaStreamGraph.cpp
--- a/content/media/MediaStreamGraph.cpp
+++ b/content/media/MediaStreamGraph.cpp
@@ -201,16 +201,21 @@ public:
    */
   void UpdateCurrentTime();
   /**
    * Update mLastActionTime to the time at which the current set of messages
    * will take effect.
    */
   void ChooseActionTime();
   /**
+   * Update the consumption state of aStream to reflect whether its data
+   * is needed or not.
+   */
+  void UpdateConsumptionState(SourceMediaStream* aStream);
+  /**
    * Extract any state updates pending in aStream, and apply them.
    */
   void ExtractPendingInput(SourceMediaStream* aStream);
   /**
    * Update "have enough data" flags in aStream.
    */
   void UpdateBufferSufficiencyState(SourceMediaStream* aStream);
   /**
@@ -608,16 +613,32 @@ MediaStreamGraphImpl::RemoveStream(Media
 
 void
 MediaStreamGraphImpl::ChooseActionTime()
 {
   mLastActionTime = GetEarliestActionTime();
 }
 
 void
+MediaStreamGraphImpl::UpdateConsumptionState(SourceMediaStream* aStream)
+{
+  bool isConsumed = !aStream->mAudioOutputs.IsEmpty() ||
+    !aStream->mVideoOutputs.IsEmpty();
+  MediaStreamListener::Consumption state = isConsumed ? MediaStreamListener::CONSUMED
+    : MediaStreamListener::NOT_CONSUMED;
+  if (state != aStream->mLastConsumptionState) {
+    aStream->mLastConsumptionState = state;
+    for (PRUint32 j = 0; j < aStream->mListeners.Length(); ++j) {
+      MediaStreamListener* l = aStream->mListeners[j];
+      l->NotifyConsumptionChanged(this, state);
+    }
+  }
+}
+
+void
 MediaStreamGraphImpl::ExtractPendingInput(SourceMediaStream* aStream)
 {
   bool finished;
   {
     MutexAutoLock lock(aStream->mMutex);
     finished = aStream->mUpdateFinished;
     for (PRInt32 i = aStream->mUpdateTracks.Length() - 1; i >= 0; --i) {
       SourceMediaStream::TrackData* data = &aStream->mUpdateTracks[i];
@@ -1261,16 +1282,17 @@ MediaStreamGraphImpl::RunThread()
       }
     }
     messageQueue.Clear();
 
     // Grab pending ProcessingEngine results.
     for (PRUint32 i = 0; i < mStreams.Length(); ++i) {
       SourceMediaStream* is = mStreams[i]->AsSourceStream();
       if (is) {
+        UpdateConsumptionState(is);
         ExtractPendingInput(is);
       }
     }
 
     GraphTime prevBlockingDecisionsMadeUntilTime = mBlockingDecisionsMadeUntilTime;
     RecomputeBlocking();
 
     PRUint32 audioStreamsActive = 0;
diff --git a/content/media/MediaStreamGraph.h b/content/media/MediaStreamGraph.h
--- a/content/media/MediaStreamGraph.h
+++ b/content/media/MediaStreamGraph.h
@@ -89,22 +89,34 @@ class MediaStreamGraph;
  * attached to a stream that has already finished, we'll call NotifyFinished.
  */
 class MediaStreamListener {
 public:
   virtual ~MediaStreamListener() {}
 
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(MediaStreamListener)
 
+  enum Consumption {
+    CONSUMED,
+    NOT_CONSUMED
+  };
+  /**
+   * Notify that the stream is hooked up and we'd like to start or stop receiving
+   * data on it. Only fires on SourceMediaStreams.
+   * The initial state is assumed to be NOT_CONSUMED.
+   */
+  virtual void NotifyConsumptionChanged(MediaStreamGraph* aGraph, Consumption aConsuming) {}
+
   enum Blocking {
     BLOCKED,
     UNBLOCKED
   };
   /**
-   * Notify that the blocking status of the stream changed.
+   * Notify that the blocking status of the stream changed. The initial state
+   * is assumed to be BLOCKED.
    */
   virtual void NotifyBlockingChanged(MediaStreamGraph* aGraph, Blocking aBlocked) {}
 
   /**
    * Notify that the stream output is advancing.
    */
   virtual void NotifyOutput(MediaStreamGraph* aGraph) {}
 
@@ -366,18 +378,21 @@ protected:
  * This is a stream into which a decoder can write audio and video.
  *
  * Audio and video can be written on any thread, but you probably want to
  * always write from the same thread to avoid unexpected interleavings.
  */
 class SourceMediaStream : public MediaStream {
 public:
   SourceMediaStream(nsDOMMediaStream* aWrapper) :
-    MediaStream(aWrapper), mMutex("mozilla::media::SourceMediaStream"),
-    mUpdateKnownTracksTime(0), mUpdateFinished(false), mDestroyed(false)
+    MediaStream(aWrapper),
+    mLastConsumptionState(MediaStreamListener::NOT_CONSUMED),
+    mMutex("mozilla::media::SourceMediaStream"),
+    mUpdateKnownTracksTime(0),
+    mUpdateFinished(false), mDestroyed(false)
   {}
 
   virtual SourceMediaStream* AsSourceStream() { return this; }
 
   // Media graph thread only
   virtual void DestroyImpl();
 
   // Call these on any thread.
@@ -466,16 +481,19 @@ protected:
       if (mUpdateTracks[i].mID == aID) {
         return &mUpdateTracks[i];
       }
     }
     NS_ERROR("Bad track ID!");
     return nsnull;
   }
 
+  // Media stream graph thread only
+  MediaStreamListener::Consumption mLastConsumptionState;
+
   // This must be acquired *before* MediaStreamGraphImpl's lock, if they are
   // held together.
   Mutex mMutex;
   // protected by mMutex
   StreamTime mUpdateKnownTracksTime;
   nsTArray<TrackData> mUpdateTracks;
   bool mUpdateFinished;
   bool mDestroyed;
