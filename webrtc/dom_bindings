# HG changeset patch
# Parent 24170913958fbf5da222bbb329b2af3014086eb9
# User Anant Narayanan <anant@kix.in>
Add gUM Desktop DOM bindings

diff --git a/dom/media/Makefile.in b/dom/media/Makefile.in
--- a/dom/media/Makefile.in
+++ b/dom/media/Makefile.in
@@ -29,10 +29,14 @@ EXPORTS_NAMESPACE = mozilla
 EXPORTS_mozilla = \
   MediaManager.h \
   $(NULL)
 
 CPPSRCS = \
   MediaManager.cpp \
   $(NULL)
 
+LOCAL_INCLUDES += \
+  -I$(topsrcdir)/media/webrtc/trunk/src \
+  $(NULL)
+
 include $(topsrcdir)/config/config.mk
 include $(topsrcdir)/config/rules.mk
diff --git a/dom/media/MediaManager.cpp b/dom/media/MediaManager.cpp
--- a/dom/media/MediaManager.cpp
+++ b/dom/media/MediaManager.cpp
@@ -1,26 +1,31 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "MediaManager.h"
 
 #include "MediaStreamGraph.h"
-#include "MediaEngineDefault.h"
-
 #include "nsIDOMFile.h"
 #include "nsIEventTarget.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIPopupWindowManager.h"
 
 #include "nsJSUtils.h"
 #include "nsDOMFile.h"
 #include "nsGlobalWindow.h"
 
+/* Using WebRTC backend on Desktops (Mac, Windows, Linux), otherwise default */
+#if defined(XP_WIN) || defined(XP_UNIX)
+#include "MediaEngineWebRTC.h"
+#else
+#include "MediaEngineDefault.h"
+#endif
+
 namespace mozilla {
 
 /**
  * Send an error back to content. The error is the form a string.
  * Do this only on the main thread.
  */
 class ErrorCallbackRunnable : public nsRunnable
 {
@@ -59,17 +64,17 @@ class SuccessCallbackRunnable : public n
 public:
   SuccessCallbackRunnable(nsIDOMGetUserMediaSuccessCallback* aSuccess,
     nsIDOMFile* aFile, PRUint64 aWindowID)
     : mSuccess(aSuccess)
     , mFile(aFile)
     , mWindowID(aWindowID) {}
 
   SuccessCallbackRunnable(nsIDOMGetUserMediaSuccessCallback* aSuccess,
-    nsIDOMMediaStream* aStream, PRUint64 aWindowID)
+    already_AddRefed<nsDOMMediaStream> aStream, PRUint64 aWindowID)
     : mSuccess(aSuccess)
     , mStream(aStream)
     , mWindowID(aWindowID) {}
 
   NS_IMETHOD
   Run()
   {
     // Only run if the window is still active.
@@ -88,165 +93,76 @@ public:
 private:
   nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccess;
   nsCOMPtr<nsIDOMFile> mFile;
   nsCOMPtr<nsIDOMMediaStream> mStream;
   PRUint64 mWindowID;
 };
 
 /**
- * This runnable creates a nsDOMMediaStream from a given MediaEngineSource
- * and returns it via a success callback. Both must be done on the main thread.
+ * Creates a MediaStream, attaches a listener and fires off a success callback
+ * to the DOM with the stream.
+ *
+ * All of this must be done on the main thread!
  */
-class GetUserMediaCallbackRunnable : public nsRunnable
+class GetUserMediaStreamRunnable : public nsRunnable
 {
 public:
-  GetUserMediaCallbackRunnable(MediaEngineSource* aSource, TrackID aId,
-    nsIDOMGetUserMediaSuccessCallback* aSuccess,
-    nsIDOMGetUserMediaErrorCallback* aError,
-    PRUint64 aWindowID,
-    StreamListeners* aListeners)
-    : mSource(aSource)
-    , mId(aId)
-    , mSuccess(aSuccess)
-    , mError(aError)
+  GetUserMediaStreamRunnable(nsIDOMGetUserMediaSuccessCallback* aSuccess,
+    MediaEngineSource* aSource, StreamListeners* aListeners,
+    PRUint64 aWindowID, TrackID aTrackID)
+    : mSuccess(aSuccess)
+    , mSource(aSource)
+    , mListeners(aListeners)
     , mWindowID(aWindowID)
-    , mListeners(aListeners) {}
+    , mTrackID(aTrackID) {}
+
+  ~GetUserMediaStreamRunnable() {}
 
   NS_IMETHOD
   Run()
   {
-    /**
-     * Normally we would now get the name & UUID for the device and ask the
-     * user permission. We will do that when we have some UI. Currently,
-     * only the Android {picture:true} backend is functional, which does not
-     * need a permission prompt, as permission is implicit by user action.
-     *
-     * See bug 748835 for progress on the desktop UI.
-     */
-    nsCOMPtr<nsDOMMediaStream> comStream = mSource->Allocate();
-    if (!comStream) {
-      NS_DispatchToMainThread(new ErrorCallbackRunnable(
-        mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
-      ));
-      return NS_OK;
-    }
+    // Create a media stream.
+    nsCOMPtr<nsDOMMediaStream> stream = nsDOMMediaStream::CreateInputStream();
 
     // Add our listener. We'll call Start() on the source when get a callback
     // that the MediaStream has started consuming. The listener is freed
     // when the page is invalidated (on navigation or close).
     GetUserMediaCallbackMediaStreamListener* listener =
-      new GetUserMediaCallbackMediaStreamListener(mSource, comStream, mId);
-    comStream->GetStream()->AddListener(listener);
+      new GetUserMediaCallbackMediaStreamListener(mSource, stream, mTrackID);
+    stream->GetStream()->AddListener(listener);
 
-    {
-      MutexAutoLock lock(*(MediaManager::Get()->GetLock()));
-      mListeners->AppendElement(listener);
+    // No need for locking because we always do this in the main thread.
+    mListeners->AppendElement(listener);
+
+    // We're in the main thread, so no worries here either.
+    WindowTable* activeWindows = MediaManager::Get()->GetActiveWindows();
+    if (activeWindows->Get(mWindowID)) {
+      mSuccess->OnSuccess(stream);
     }
 
-    // Add the listener to CallbackRunnables so it can be invalidated.
-    NS_DispatchToMainThread(new SuccessCallbackRunnable(
-      mSuccess, comStream.get(), mWindowID
-    ));
     return NS_OK;
   }
 
 private:
-  nsCOMPtr<MediaEngineSource> mSource;
-  TrackID mId;
   nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccess;
-  nsCOMPtr<nsIDOMGetUserMediaErrorCallback> mError;
+  nsRefPtr<MediaEngineSource> mSource;
+  StreamListeners* mListeners;
   PRUint64 mWindowID;
-  StreamListeners* mListeners;
-};
-
-/**
- * This runnable creates a nsIDOMFile from a MediaEngineVideoSource and
- * passes the result back via a SuccessRunnable. Both must be done on the
- * main thread.
- */
-class GetUserMediaSnapshotCallbackRunable : public nsRunnable
-{
-public:
-  GetUserMediaSnapshotCallbackRunable(MediaEngineSource* aSource,
-    PRUint32 aDuration,
-    nsIDOMGetUserMediaSuccessCallback* aSuccessCallback,
-    nsIDOMGetUserMediaErrorCallback* aErrorCallback,
-    nsPIDOMWindow* aWindow)
-    : mSource(aSource)
-    , mDuration(aDuration)
-    , mSuccessCallback(aSuccessCallback)
-    , mErrorCallback(aErrorCallback)
-    , mWindow(aWindow) {}
-
-  NS_IMETHOD
-  Run()
-  {
-    mWindowID = mWindow->WindowID();
-
-    // Before getting a snapshot, check if page is allowed to open a popup.
-    // We do this because {picture:true} on all platforms will open a new
-    // "window" to let the user preview or select an image.
-
-    if (mWindow->GetPopupControlState() <= openControlled) {
-      return NS_OK;
-    }
-    
-    nsCOMPtr<nsIPopupWindowManager> pm =
-      do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
-    if (!pm) {
-      return NS_OK;
-    }
-
-    PRUint32 permission;
-    nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
-    pm->TestPermission(doc->GetDocumentURI(), &permission);
-    if (permission == nsIPopupWindowManager::DENY_POPUP) {
-      nsCOMPtr<nsIDOMDocument> domDoc = mWindow->GetExtantDocument();
-      nsGlobalWindow::FirePopupBlockedEvent(
-        domDoc, mWindow, nsnull, EmptyString(), EmptyString()
-      );
-      return NS_OK;
-    }
-
-    nsCOMPtr<nsDOMMediaStream> comStream = mSource->Allocate();
-    if (!comStream) {
-      NS_DispatchToMainThread(new ErrorCallbackRunnable(
-        mErrorCallback, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
-      ));
-      return NS_OK;
-    }
-
-    nsCOMPtr<nsIDOMFile> file;
-    mSource->Snapshot(mDuration, getter_AddRefs(file));
-    mSource->Deallocate();
-
-    NS_DispatchToMainThread(new SuccessCallbackRunnable(
-      mSuccessCallback, file, mWindowID
-    ));
-    return NS_OK;
-  }
-
-private:
-  nsCOMPtr<MediaEngineSource> mSource;
-  PRUint32 mDuration;
-  nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccessCallback;
-  nsCOMPtr<nsIDOMGetUserMediaErrorCallback>  mErrorCallback;
-  nsCOMPtr<nsPIDOMWindow> mWindow;
-
-  PRUint64 mWindowID;
+  TrackID mTrackID;
 };
 
 /**
  * Runs on a seperate thread and is responsible for enumerating devices.
  * Depending on whether a picture or stream was asked for, either
- * GetUserMediaCallbackRunnable or GetUserMediaSnapshotCallbackRunnable
- * will be dispatched to the main thread to return the result to DOM.
+ * ProcessGetUserMedia or ProcessGetUserMediaSnapshot is called, and the results
+ * are sent back to the DOM.
  *
- * Do not run this on the main thread.
+ * Do not run this on the main thread. The success and error callbacks *MUST*
+ * be dispatched on the main thread!
  */
 class GetUserMediaRunnable : public nsRunnable
 {
 public:
   GetUserMediaRunnable(bool aAudio, bool aVideo, bool aPicture,
     nsIDOMGetUserMediaSuccessCallback* aSuccess,
     nsIDOMGetUserMediaErrorCallback* aError,
     nsPIDOMWindow* aWindow, StreamListeners* aListeners)
@@ -293,34 +209,117 @@ public:
     if (mAudio) {
       SendAudio();
       return NS_OK;
     }
 
     return NS_OK;
   }
 
+  /**
+   * Allocates a video or audio device and returns a MediaStream via
+   * a GetUserMediaStreamRunnable. Runs off the main thread.
+   */
+  void
+  ProcessGetUserMedia(MediaEngineSource* aSource, TrackID aTrackID)
+  {
+    /**
+     * Normally we would now get the name & UUID for the device and ask the
+     * user permission. We will do that when we have some UI. Currently,
+     * only the Android {picture:true} backend is functional, which does not
+     * need a permission prompt, as permission is implicit by user action.
+     *
+     * See bug 748835 for progress on the desktop UI.
+     */
+    nsresult rv = aSource->Allocate();
+    if (NS_FAILED(rv)) {
+      NS_DispatchToMainThread(new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
+      ));
+      return;
+    }
+
+    NS_DispatchToMainThread(new GetUserMediaStreamRunnable(
+      mSuccess.get(), aSource, mListeners, mWindowID, aTrackID
+    ));
+    return;
+  }
+
+  /**
+   * Allocates a video device, takes a snapshot and returns a DOMFile via
+   * a SuccessRunnable or an error via the ErrorRunnable. Off the main thread.
+   */
+  void
+  ProcessGetUserMediaSnapshot(MediaEngineSource* aSource, int aDuration)
+  {
+    /**
+     * We don't retain a reference to nsPIDOMWindow since we're not on the
+     * main thread. Before getting a snapshot, check if page is allowed to
+     * open a popup. We do this because {picture:true} will open a new "window"
+     * to let the user preview or select an image, on Android. The desktop UI
+     * for {picture:true} is TBD, at which may point we can decide whether to
+     * extend this test there as well.
+     */
+#if !defined(XP_WIN) && !defined(XP_UNIX)
+    if (mWindow && (mWindow->GetPopupControlState() <= openControlled)) {
+      return;
+    }
+    nsCOMPtr<nsIPopupWindowManager> pm =
+      do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
+    if (!pm) {
+      return;
+    }
+
+    PRUint32 permission;
+    nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
+    pm->TestPermission(doc->GetDocumentURI(), &permission);
+    if (mWindow && (permission == nsIPopupWindowManager::DENY_POPUP)) {
+      nsCOMPtr<nsIDOMDocument> domDoc = mWindow->GetExtantDocument();
+      nsGlobalWindow::FirePopupBlockedEvent(
+        domDoc, mWindow, nsnull, EmptyString(), EmptyString()
+      );
+      return;
+    }
+#endif
+
+    nsresult rv = aSource->Allocate();
+    if (NS_FAILED(rv)) {
+      NS_DispatchToMainThread(new ErrorCallbackRunnable(
+        mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
+      ));
+      return;
+    }
+
+    nsCOMPtr<nsIDOMFile> file;
+    aSource->Snapshot(aDuration, getter_AddRefs(file));
+    aSource->Deallocate();
+
+    NS_DispatchToMainThread(new SuccessCallbackRunnable(
+      mSuccess, file, mWindowID
+    ));
+    return;
+  }
+
   // {picture:true}
   void
   SendPicture()
   {
     nsTArray<nsRefPtr<MediaEngineVideoSource> > videoSources;
     mManager->GetBackend()->EnumerateVideoDevices(&videoSources);
 
     PRUint32 count = videoSources.Length();
     if (!count) {
       NS_DispatchToMainThread(new ErrorCallbackRunnable(
         mError, NS_LITERAL_STRING("NO_DEVICES_FOUND"), mWindowID
       ));
       return;
     }
+
     MediaEngineVideoSource* videoSource = videoSources[count - 1];
-    NS_DispatchToMainThread(new GetUserMediaSnapshotCallbackRunable(
-      videoSource, 0 /* duration */, mSuccess, mError, mWindow
-    ));
+    ProcessGetUserMediaSnapshot(videoSource, 0 /* duration */);
   }
 
   // {video:true}
   void
   SendVideo()
   {
     nsTArray<nsRefPtr<MediaEngineVideoSource> > videoSources;
     mManager->GetBackend()->EnumerateVideoDevices(&videoSources);
@@ -329,19 +328,17 @@ public:
     if (!count) {
       NS_DispatchToMainThread(new ErrorCallbackRunnable(
         mError, NS_LITERAL_STRING("NO_DEVICES_FOUND"), mWindowID
       ));
       return;
     }
 
     MediaEngineVideoSource* videoSource = videoSources[count - 1];
-    NS_DispatchToMainThread(new GetUserMediaCallbackRunnable(
-      videoSource, kVideoTrack, mSuccess, mError, mWindowID, mListeners
-    ));
+    ProcessGetUserMedia(videoSource, kVideoTrack);
   }
 
   // {audio:true}
   void
   SendAudio()
   {
     nsTArray<nsRefPtr<MediaEngineAudioSource> > audioSources;
     mManager->GetBackend()->EnumerateAudioDevices(&audioSources);
@@ -350,29 +347,27 @@ public:
     if (!count) {
       NS_DispatchToMainThread(new ErrorCallbackRunnable(
         mError, NS_LITERAL_STRING("NO_DEVICES_FOUND"), mWindowID
       ));
       return;
     }
 
     MediaEngineAudioSource* audioSource = audioSources[count - 1];
-    NS_DispatchToMainThread(new GetUserMediaCallbackRunnable(
-      audioSource, kAudioTrack, mSuccess, mError, mWindowID, mListeners
-    ));
+    ProcessGetUserMedia(audioSource, kAudioTrack);
   }
 
 private:
   bool mAudio;
   bool mVideo;
   bool mPicture;
 
   nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> mSuccess;
   nsCOMPtr<nsIDOMGetUserMediaErrorCallback> mError;
-  nsCOMPtr<nsPIDOMWindow> mWindow;
+  nsPIDOMWindow* mWindow;
   StreamListeners* mListeners;
 
   MediaManager* mManager;
   PRUint64 mWindowID;
 };
 
 
 nsRefPtr<MediaManager> MediaManager::sSingleton;
@@ -410,17 +405,17 @@ MediaManager::GetUserMedia(nsPIDOMWindow
   // when this window is closed or navigated away from.
   PRUint64 windowID = aWindow->WindowID();
   StreamListeners* listeners = mActiveWindows.Get(windowID);
   if (!listeners) {
     listeners = new StreamListeners;
     mActiveWindows.Put(windowID, listeners);
   }
 
-  // Pass runanbles along to GetUserMediaRunnable so it can add the
+  // Pass runnables along to GetUserMediaRunnable so it can add the
   // MediaStreamListener to the runnable list.
   nsCOMPtr<nsIRunnable> gUMRunnable = new GetUserMediaRunnable(
     audio, video, picture, onSuccess, onError, aWindow, listeners
   );
 
   // Reuse the same thread to save memory.
   if (!mMediaThread) {
     rv = NS_NewThread(getter_AddRefs(mMediaThread));
@@ -429,21 +424,26 @@ MediaManager::GetUserMedia(nsPIDOMWindow
 
   mMediaThread->Dispatch(gUMRunnable, NS_DISPATCH_NORMAL);
   return NS_OK;
 }
 
 MediaEngine*
 MediaManager::GetBackend()
 {
-  // Plugin backends as appropriate. Only default is available for now, which
-  // also includes picture support for Android.
+  // Plugin backends as appropriate. The default engine also currently
+  // includes picture support for Android.
   if (!mBackend) {
+#if defined(XP_WIN) || defined(XP_UNIX)
+    mBackend = new MediaEngineWebRTC();
+#else
     mBackend = new MediaEngineDefault();
+#endif
   }
+
   return mBackend;
 }
 
 WindowTable*
 MediaManager::GetActiveWindows()
 {
   return &mActiveWindows;
 }
@@ -453,17 +453,16 @@ MediaManager::OnNavigation(PRUint64 aWin
 {
   // Invalidate this window. The runnables check this value before making
   // a call to content.
   StreamListeners* listeners = mActiveWindows.Get(aWindowID);
   if (!listeners) {
     return;
   }
 
-  MutexAutoLock lock(*mLock);
   PRUint32 length = listeners->Length();
   for (PRUint32 i = 0; i < length; i++) {
     nsRefPtr<GetUserMediaCallbackMediaStreamListener> listener =
       listeners->ElementAt(i);
     listener->Invalidate();
     listener = nsnull;
   }
   listeners->Clear();
diff --git a/dom/media/MediaManager.h b/dom/media/MediaManager.h
--- a/dom/media/MediaManager.h
+++ b/dom/media/MediaManager.h
@@ -22,17 +22,17 @@ namespace mozilla {
  */
 class GetUserMediaCallbackMediaStreamListener : public MediaStreamListener
 {
 public:
   GetUserMediaCallbackMediaStreamListener(MediaEngineSource* aSource,
     nsDOMMediaStream* aStream, TrackID aListenId)
     : mSource(aSource)
     , mStream(aStream)
-    , mId(aListenId)
+    , mID(aListenId)
     , mValid(true) {}
 
   void
   Invalidate()
   {
     if (!mValid) {
       return;
     }
@@ -41,38 +41,37 @@ public:
     mSource->Stop();
     mSource->Deallocate();
   }
 
   void
   NotifyConsumptionChanged(MediaStreamGraph* aGraph, Consumption aConsuming)
   {
     if (aConsuming == CONSUMED) {
-      nsRefPtr<SourceMediaStream> stream = mStream->GetStream()->AsSourceStream();
-      mSource->Start(stream, mId);
+      SourceMediaStream* stream = mStream->GetStream()->AsSourceStream();
+      mSource->Start(stream, mID);
       return;
     }
 
     // NOT_CONSUMED
     Invalidate();
     return;
   }
 
   void NotifyBlockingChanged(MediaStreamGraph* aGraph, Blocking aBlocked) {}
   void NotifyOutput(MediaStreamGraph* aGraph) {}
   void NotifyFinished(MediaStreamGraph* aGraph) {}
   void NotifyQueuedTrackChanges(MediaStreamGraph* aGraph, TrackID aID,
     TrackRate aTrackRate, TrackTicks aTrackOffset,
     PRUint32 aTrackEvents, const MediaSegment& aQueuedMedia) {}
-  nsresult Run() { return NS_OK; }
 
 private:
-  nsCOMPtr<MediaEngineSource> mSource;
+  nsRefPtr<MediaEngineSource> mSource;
   nsCOMPtr<nsDOMMediaStream> mStream;
-  TrackID mId;
+  TrackID mID;
   bool mValid;
 };
 
 typedef nsTArray<nsRefPtr<GetUserMediaCallbackMediaStreamListener> > StreamListeners;
 typedef nsClassHashtable<nsUint64HashKey, StreamListeners> WindowTable;
 
 class MediaManager MOZ_FINAL : public nsIObserver {
 public:
@@ -84,45 +83,38 @@ public:
       obs->AddObserver(sSingleton, "xpcom-shutdown", false);
     }
     return sSingleton;
   }
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
 
-  Mutex* GetLock() {
-    return mLock;
-  }
-
   MediaEngine* GetBackend();
   WindowTable* GetActiveWindows();
 
   nsresult GetUserMedia(nsPIDOMWindow* aWindow, nsIMediaStreamOptions* aParams,
     nsIDOMGetUserMediaSuccessCallback* onSuccess,
     nsIDOMGetUserMediaErrorCallback* onError);
   void OnNavigation(PRUint64 aWindowID);
 
 private:
   // Make private because we want only one instance of this class
   MediaManager()
   : mBackend(nsnull)
   , mMediaThread(nsnull) {
-    mLock = new mozilla::Mutex("MediaManager::StreamListenersLock");
     mActiveWindows.Init();
   };
   MediaManager(MediaManager const&) {};
 
   ~MediaManager() {
-    delete mLock;
     delete mBackend;
   };
 
   MediaEngine* mBackend;
   nsCOMPtr<nsIThread> mMediaThread;
 
-  Mutex* mLock;
   WindowTable mActiveWindows;
 
   static nsRefPtr<MediaManager> sSingleton;
 };
 
 } // namespace mozilla
