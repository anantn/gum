# HG changeset patch
# Parent a09014357391d8db9fd1824dfc456ab1ad7aec42
diff --git a/content/media/Makefile.in b/content/media/Makefile.in
--- a/content/media/Makefile.in
+++ b/content/media/Makefile.in
@@ -55,30 +55,34 @@ EXPORTS = \
   MediaResource.h \
   nsAudioAvailableEventManager.h \
   nsBuiltinDecoder.h \
   nsBuiltinDecoderStateMachine.h \
   nsBuiltinDecoderReader.h \
   nsDOMMediaStream.h \
   nsMediaDecoder.h \
   nsMediaCache.h \
+  nsUserMedia.h \
+  nsUserMediaConvert.h \
   StreamBuffer.h \
   TimeVarying.h \
   VideoFrameContainer.h \
   VideoUtils.h \
   $(NULL)
 
 CPPSRCS = \
   GraphManager.cpp \
   MediaResource.cpp \
   nsAudioAvailableEventManager.cpp \
   nsBuiltinDecoder.cpp \
   nsBuiltinDecoderStateMachine.cpp \
   nsBuiltinDecoderReader.cpp \
   nsDOMMediaStream.cpp \
+  nsUserMedia.cpp \
+  nsUserMediaConvert.cpp \
   nsMediaDecoder.cpp \
   nsMediaCache.cpp \
   StreamBuffer.cpp \
   VideoFrameContainer.cpp \
   VideoUtils.cpp \
   $(NULL)
 
 ifdef MOZ_SYDNEYAUDIO
@@ -110,16 +114,17 @@ endif
 
 ifdef ENABLE_TESTS
 PARALLEL_DIRS += test
 endif
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/media/webrtc/webrtc-config.mk
 include $(topsrcdir)/ipc/chromium/chromium-config.mk
 include $(topsrcdir)/config/rules.mk
 
 INCLUDES += \
   -I$(srcdir)/../base/src \
   -I$(srcdir)/../html/content/src \
   $(NULL)
 
diff --git a/content/media/nsUserMedia.cpp b/content/media/nsUserMedia.cpp
new file mode 100644
--- /dev/null
+++ b/content/media/nsUserMedia.cpp
@@ -0,0 +1,350 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2012
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Anant Narayanan <anant@kix.in>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "stdio.h"
+#include "nsUserMedia.h"
+
+/********************************************************************
+  nsUserMedia: nsIDOMUserMedia
+********************************************************************/
+NS_IMPL_ISUPPORTS0(nsUserMedia)
+nsUserMedia::nsUserMedia()
+{
+  vSource = NULL;
+}
+
+nsUserMedia::~nsUserMedia()
+{
+  if (vSource != NULL) {
+    delete vSource;
+  }
+}
+
+void
+nsUserMedia::GetUserMedia(nsPIDOMWindow *window,
+  const JS::Value& val,
+  nsIDOMGetUserMediaSuccessCallback* success,
+  nsIDOMGetUserMediaErrorCallback* error,
+  nsIDOMCanvasRenderingContext2D* ctx)
+{
+	// Implement permissions per *window
+  // Parse jsval& val
+
+  if (vSource == NULL) {
+    vSource = new nsUserMediaVideoSource();
+    if (!vSource) {
+      // Implement nsIDOMUserMediaERror
+      // error->onError();
+      return;
+    }
+  }
+
+  nsUserMediaStream *stream = new nsUserMediaStream();
+  stream->InitVideo(vSource);
+  nsCOMPtr<nsIDOMUserMediaStream> mStream(stream);
+  success->OnSuccess(mStream);
+
+  // Hack
+  if (ctx != NULL) {
+    fprintf(stderr, "GetUserMedia:: Canvas context is NON-NULL\n");
+    stream->StartWithCanvas(ctx);
+  }
+  return;
+}
+
+/********************************************************************
+  nsUserMediaStream: nsIDOMUserMediaStream
+********************************************************************/
+NS_IMPL_ISUPPORTS1(nsUserMediaStream, nsIDOMUserMediaStream)
+
+nsUserMediaStream::nsUserMediaStream()
+{ 
+}
+
+nsUserMediaStream::~nsUserMediaStream()
+{ 
+}
+
+void
+nsUserMediaStream::InitVideo(nsUserMediaVideoSource* src)
+{
+  vSource = src;
+}
+
+NS_IMETHODIMP
+nsUserMediaStream::StartWithCanvas(nsIDOMCanvasRenderingContext2D *ctx)
+{
+    fprintf(stderr, "UserMediaStream::StartWithCanvas\n");
+    return vSource->StartWithCanvas(ctx);
+}
+
+NS_IMETHODIMP
+nsUserMediaStream::Stop()
+{
+    return vSource->Stop();
+}
+
+/********************************************************************
+  nsUserMediaVideoSource
+********************************************************************/
+nsUserMediaVideoSource::nsUserMediaVideoSource()
+{
+  int error = 0;
+  channel = -1;
+
+  ptrViE = webrtc::VideoEngine::Create();
+  if (ptrViE == NULL) {
+    fprintf(stderr, "ERROR in VideoEngine::Create\n");
+    return;
+  }
+
+  ptrViEBase = webrtc::ViEBase::GetInterface(ptrViE);
+  if (ptrViEBase == NULL) {
+    fprintf(stderr, "ERROR in VideoEngine::GetInterface\n");
+    return;
+  }
+
+  error = ptrViEBase->Init();
+  if (error == -1) {
+    fprintf(stderr, "ERROR in VideoEngine::Init\n");
+    return;
+  }
+
+  error = ptrViEBase->CreateChannel(channel);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in VideoEngine::CreateChannel\n");
+    return;
+  }
+
+  // Get first available device
+  ptrViECapture = webrtc::ViECapture::GetInterface(ptrViE);
+  if (ptrViEBase == NULL) {
+    fprintf(stderr, "ERROR in ViECapture::GetInterface\n");
+    return;
+  }
+
+  int num = ptrViECapture->NumberOfCaptureDevices();
+  if (num <= 0) {
+    fprintf(stderr, "ERROR no video devices found\n");
+    return;
+  } else {
+    fprintf(stderr, "GetUserMedia:: Found %d devices!\n", num);
+  }
+
+  const unsigned int KMaxDeviceNameLength = 128;
+  const unsigned int KMaxUniqueIdLength = 256;
+  char deviceName[KMaxDeviceNameLength];
+  memset(deviceName, 0, KMaxDeviceNameLength);
+  char uniqueId[KMaxUniqueIdLength];
+  memset(uniqueId, 0, KMaxUniqueIdLength);
+  
+  error = ptrViECapture->GetCaptureDevice(
+    0, deviceName, KMaxDeviceNameLength, uniqueId, KMaxUniqueIdLength
+  );
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViECapture::GetCaptureDevice\n");
+    return;
+  }
+
+  // Set to third capability
+  error = ptrViECapture->GetCaptureCapability(
+    uniqueId, KMaxUniqueIdLength, 2, caps
+  );
+
+  captureID = 0;
+  error = ptrViECapture->AllocateCaptureDevice(
+    uniqueId, KMaxUniqueIdLength, captureID
+  );
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ptrViECapture::AllocateCaptureDevice\n");
+    return;
+  }
+}
+
+nsUserMediaVideoSource::~nsUserMediaVideoSource()
+{
+  int error = 0;
+
+  error = ptrViECapture->ReleaseCaptureDevice(captureID);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ptrViECapture::ReleaseCaptureDevice\n");
+  }
+
+  error = ptrViEBase->DeleteChannel(channel);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ptrViECapture::DeleteChannel\n");
+  }
+
+  ptrViECapture->Release();
+  ptrViEBase->Release();
+
+  if (webrtc::VideoEngine::Delete(ptrViE) == false) {
+    fprintf(stderr, "ERROR in VideoEngine::Delete\n");
+  }
+}
+
+int
+nsUserMediaVideoSource::FrameSizeChange(
+  unsigned int w, unsigned int h, unsigned int streams)
+{
+  fprintf(stderr, "Got FrameSizeChange: %d %d\n", w, h);
+  width = w;
+  height = h;
+  return -1;
+}
+
+int
+nsUserMediaVideoSource::DeliverFrame(
+  unsigned char* buffer, int size, unsigned int time)
+{
+  // Paint to canvas
+  fprintf(stderr, "Got frame of size: %d\n", size);
+
+  int fsize = width * height * 4;
+  if (canvas && fsize != 0) {
+    // Convert i420 to rgb32
+    // Use h/w accelerated optimized function to do this
+    nsAutoArrayPtr<PRUint8> rgb32(new PRUint8[fsize]);
+    I420toRGB32(width, height,
+      (const char *)buffer, (char *)rgb32.get()
+    );
+
+    nsCOMPtr<nsIRunnable> render = new CanvasRenderer(
+      canvas, width, height, rgb32, fsize
+    );
+    NS_DispatchToMainThread(render);
+  }
+
+  return 0;
+}
+
+// Make both of the following async with PRThread f.e.:
+// https://github.com/mozilla/rainbow/blob/master/components/MediaRecorder.cpp#L655
+
+nsresult
+nsUserMediaVideoSource::StartWithCanvas(nsIDOMCanvasRenderingContext2D *ctx)
+{
+  canvas = ctx;
+  PR_CreateThread(
+    PR_SYSTEM_THREAD,
+    nsUserMediaVideoSource::StartWithCanvasThread, this,
+    PR_PRIORITY_NORMAL,
+    PR_GLOBAL_THREAD,
+    PR_JOINABLE_THREAD, 0
+  );
+  return NS_OK;
+}
+
+void
+nsUserMediaVideoSource::StartWithCanvasThread(void *data)
+{
+  nsUserMediaVideoSource *vs = static_cast<nsUserMediaVideoSource*>(data);
+  fprintf(stderr, "UserMediaVideoSource::StartWithCanvas\n");
+
+  int error = 0;
+  error = vs->ptrViECapture->ConnectCaptureDevice(vs->captureID, vs->channel);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViECapture::ConnectCaptureDevice\n");
+    return;
+  }
+
+  fprintf(stderr, "UserMediaVideoSource::StartWithCanvas -> ConnectCaptureDevice done\n");
+
+  error = vs->ptrViECapture->StartCapture(vs->captureID, vs->caps);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViECapture::StartCapture\n");
+    return;
+  }
+
+  fprintf(stderr, "UserMediaVideoSource::StartWithCanvas -> StartCapture done\n");
+
+  vs->ptrViERender = webrtc::ViERender::GetInterface(vs->ptrViE);
+  if (vs->ptrViERender == NULL) {
+    fprintf(stderr, "ERROR in ViERender::GetInterface\n");
+    return;
+  }
+
+  error = vs->ptrViERender->AddRenderer(vs->captureID, webrtc::kVideoI420, vs);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViERender::AddRenderer\n");
+    return;
+  }
+
+  fprintf(stderr, "UserMediaVideoSource::StartWithCanvas -> AddRenderer done\n");
+
+  error = vs->ptrViERender->StartRender(vs->captureID);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViERender::StartRender\n");
+    return;
+  }
+
+  return;
+}
+
+nsresult
+nsUserMediaVideoSource::Stop()
+{
+  int error = 0;
+
+  error = ptrViERender->StopRender(captureID);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViERender::StopRender\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  error = ptrViERender->RemoveRenderer(captureID);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViERender::RemoveRenderer\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  error = ptrViECapture->StopCapture(captureID);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViECapture::StopCapture\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  error = ptrViECapture->DisconnectCaptureDevice(channel);
+  if (error == -1) {
+    fprintf(stderr, "ERROR in ViECapture::DisconnectCaptureDevice\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  ptrViERender->Release();
+  ptrViECapture->Release();
+
+  return NS_OK;
+}
diff --git a/content/media/nsUserMedia.h b/content/media/nsUserMedia.h
new file mode 100644
--- /dev/null
+++ b/content/media/nsUserMedia.h
@@ -0,0 +1,159 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2012
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Anant Narayanan <anant@kix.in>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef NSUSERMEDIA_H_
+#define NSUSERMEDIA_H_
+
+#include "nsIRunnable.h"
+#include "nsPIDOMWindow.h"
+#include "nsIDOMUserMedia.h"
+#include "nsIDOMCanvasRenderingContext2D.h"
+
+#include "jsapi.h"
+#include "prthread.h"
+#include "nsMemory.h"
+#include "nsCOMPtr.h"
+#include "nsAutoPtr.h"
+#include "nsThreadUtils.h"
+#include "nsUserMediaConvert.h"
+
+#include "video_engine/include/vie_base.h"
+#include "video_engine/include/vie_codec.h"
+#include "video_engine/include/vie_render.h"
+#include "video_engine/include/vie_capture.h"
+
+class nsUserMediaStream;
+class nsUserMediaVideoSource;
+
+class nsUserMedia : public nsISupports
+{
+public:
+  NS_DECL_ISUPPORTS
+  nsUserMedia();
+
+  void GetUserMedia(
+    nsPIDOMWindow*, const JS::Value&,
+    nsIDOMGetUserMediaSuccessCallback*,
+    nsIDOMGetUserMediaErrorCallback*,
+    nsIDOMCanvasRenderingContext2D*
+  );
+
+protected:
+  nsUserMediaVideoSource *vSource;
+
+private:
+  ~nsUserMedia();
+
+};
+
+class nsUserMediaStream : public nsIDOMUserMediaStream
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMUSERMEDIASTREAM
+
+  nsUserMediaStream();
+  void InitVideo(nsUserMediaVideoSource*);
+
+protected:
+  nsUserMediaVideoSource *vSource;
+
+private:
+  ~nsUserMediaStream();
+
+};
+
+class nsUserMediaVideoSource : public webrtc::ExternalRenderer {
+public:
+  nsUserMediaVideoSource();
+  ~nsUserMediaVideoSource();
+  nsresult StartWithCanvas(nsIDOMCanvasRenderingContext2D *ctx);
+  nsresult Stop();
+
+protected:
+  int width;
+  int height;
+  int frames;
+  int channel;
+  int captureID;
+  webrtc::VideoEngine* ptrViE;
+  webrtc::ViEBase* ptrViEBase;
+  webrtc::ViECapture* ptrViECapture;
+  webrtc::ViERender* ptrViERender;
+  webrtc::CaptureCapability caps;
+
+  nsIDOMCanvasRenderingContext2D* canvas;
+  static void StartWithCanvasThread(void *data);
+
+  // ViEExternalRenderer
+  int FrameSizeChange(
+    unsigned int, unsigned int, unsigned int
+  );
+  int DeliverFrame(
+    unsigned char*, int, unsigned int
+  );
+};
+
+/* 
+ * Rendering on Canvas happens on the main thread as this runnable.
+ * This is not very performant, we should move to rendering inside a <video>
+ * so that Gecko can use hardware acceleration.
+ */
+class CanvasRenderer : public nsRunnable {
+public:
+  CanvasRenderer(
+    nsIDOMCanvasRenderingContext2D *pCtx, PRUint32 width, PRUint32 height,
+    nsAutoArrayPtr<PRUint8> &pData, PRUint32 pDataSize)
+    : m_pCtx(pCtx), m_width(width), m_height(height),
+        m_pData(pData), m_pDataSize(pDataSize) {}
+
+  NS_IMETHOD Run() {
+    return m_pCtx->PutImageData_explicit(
+        0, 0, m_width, m_height, m_pData.get(), m_pDataSize,
+        PR_TRUE, 0, 0, m_width, m_height
+    );
+  }
+
+private:
+  nsIDOMCanvasRenderingContext2D *m_pCtx;
+  PRUint32 m_width;
+  PRUint32 m_height;
+  nsAutoArrayPtr<PRUint8> m_pData;
+  PRUint32 m_pDataSize;
+
+};
+
+#endif /* NSUSERMEDIA_H_ */
diff --git a/content/media/nsUserMediaConvert.cpp b/content/media/nsUserMediaConvert.cpp
new file mode 100644
--- /dev/null
+++ b/content/media/nsUserMediaConvert.cpp
@@ -0,0 +1,186 @@
+#include "nsUserMediaConvert.h"
+
+enum {
+	CLIP_SIZE = 811,
+	CLIP_OFFSET = 277,
+	YMUL = 298,
+	RMUL = 409,
+	BMUL = 516,
+	G1MUL = -100,
+	G2MUL = -208,
+};
+
+static int tables_initialized = 0;
+
+static int yuv2rgb_y[256];
+static int yuv2rgb_r[256];
+static int yuv2rgb_b[256];
+static int yuv2rgb_g1[256];
+static int yuv2rgb_g2[256];
+
+static unsigned long yuv2rgb_clip[CLIP_SIZE];
+static unsigned long yuv2rgb_clip8[CLIP_SIZE];
+static unsigned long yuv2rgb_clip16[CLIP_SIZE];
+
+#define COMPOSE_RGB(yc, rc, gc, bc)		\
+	( 0xff000000 |				\
+	  yuv2rgb_clip16[(yc) + (rc)] |		\
+	  yuv2rgb_clip8[(yc) + (gc)] |		\
+	  yuv2rgb_clip[(yc) + (bc)] )
+
+static void init_yuv2rgb_tables(void)
+{
+	int i;
+
+	for (i = 0; i < 256; ++i) {
+		yuv2rgb_y[i] = (YMUL * (i - 16) + 128) >> 8;
+		yuv2rgb_r[i] = (RMUL * (i - 128)) >> 8;
+		yuv2rgb_b[i] = (BMUL * (i - 128)) >> 8;
+		yuv2rgb_g1[i] = (G1MUL * (i - 128)) >> 8;
+		yuv2rgb_g2[i] = (G2MUL * (i - 128)) >> 8;
+	}
+	for (i = 0 ; i < CLIP_OFFSET; ++i) {
+		yuv2rgb_clip[i] = 0;
+		yuv2rgb_clip8[i] = 0;
+		yuv2rgb_clip16[i] = 0;
+	}
+	for (; i < CLIP_OFFSET + 256; ++i) {
+		yuv2rgb_clip[i] = i - CLIP_OFFSET;
+		yuv2rgb_clip8[i] = (i - CLIP_OFFSET) << 8;
+		yuv2rgb_clip16[i] = (i - CLIP_OFFSET) << 16;
+	}
+	for (; i < CLIP_SIZE; ++i) {
+		yuv2rgb_clip[i] = 255;
+		yuv2rgb_clip8[i] = 255 << 8;
+		yuv2rgb_clip16[i] = 255 << 16;
+	}
+
+	tables_initialized = 1;
+}
+
+/*
+ * Convert i420 to RGB32 (0xBBGGRRAA).
+ * NOTE: size of dest must be >= width * height * 4
+ *
+ * This function uses precalculated tables that are initialized
+ * on the first run.
+ */
+int
+I420toRGB32(int width, int height, const char *src, char *dst)
+{
+	int i, j;
+	unsigned int *dst_odd;
+	unsigned int *dst_even;
+	const unsigned char *u;
+	const unsigned char *v;
+	const unsigned char *y_odd;
+	const unsigned char *y_even;
+
+	if (!tables_initialized)
+		init_yuv2rgb_tables();
+
+	dst_even = (unsigned int *)dst;
+	dst_odd = dst_even + width;
+
+	y_even = (const unsigned char *)src;
+	y_odd = y_even + width;
+	u = y_even + width * height;
+	v = u + ((width * height) >> 2);
+
+	for (i = 0; i < height / 2; ++i) {
+		for (j = 0; j < width / 2; ++j) {
+			const int rc = yuv2rgb_r[*v];
+			const int gc = yuv2rgb_g1[*v] + yuv2rgb_g2[*u];
+			const int bc = yuv2rgb_b[*u];
+			const int yc0_even = CLIP_OFFSET + yuv2rgb_y[*y_even++];
+			const int yc1_even = CLIP_OFFSET + yuv2rgb_y[*y_even++];
+			const int yc0_odd = CLIP_OFFSET + yuv2rgb_y[*y_odd++];
+			const int yc1_odd = CLIP_OFFSET + yuv2rgb_y[*y_odd++];
+
+			*dst_even++ = COMPOSE_RGB(yc0_even, bc, gc, rc);
+			*dst_even++ = COMPOSE_RGB(yc1_even, bc, gc, rc);
+			*dst_odd++ = COMPOSE_RGB(yc0_odd, bc, gc, rc);
+			*dst_odd++ = COMPOSE_RGB(yc1_odd, bc, gc, rc);
+			
+			++u;
+			++v;
+		}
+
+		y_even += width;
+		y_odd += width;
+		dst_even += width;
+		dst_odd += width;
+	}
+
+	return 0;
+}
+
+/*
+ * Convert RGB32 to i420. NOTE: size of dest must be >= width * height * 3 / 2
+ * Based on formulas found at http://en.wikipedia.org/wiki/YUV  (libvidcap)
+ */
+int
+RGB32toI420(int width, int height, const char *src, char *dst)
+{
+    int i, j;
+    unsigned char *dst_y_even;
+    unsigned char *dst_y_odd;
+    unsigned char *dst_u;
+    unsigned char *dst_v;
+    const unsigned char *src_even;
+    const unsigned char *src_odd;
+
+    src_even = (const unsigned char *)src;
+    src_odd = src_even + width * 4;
+
+    dst_y_even = (unsigned char *)dst;
+    dst_y_odd = dst_y_even + width;
+    dst_u = dst_y_even + width * height;
+    dst_v = dst_u + ((width * height) >> 2);
+
+    for (i = 0; i < height / 2; ++i) {
+        for (j = 0; j < width / 2; ++j) {
+            short r, g, b;
+            r = *src_even++;
+            g = *src_even++;
+            b = *src_even++;
+
+            ++src_even;
+            *dst_y_even++ = (unsigned char)
+                ((( r * 66 + g * 129 + b * 25 + 128 ) >> 8 ) + 16);
+            *dst_u++ = (unsigned char)
+                ((( r * -38 - g * 74 + b * 112 + 128 ) >> 8 ) + 128);
+            *dst_v++ = (unsigned char)
+                ((( r * 112 - g * 94 - b * 18 + 128 ) >> 8 ) + 128);
+
+            r = *src_even++;
+            g = *src_even++;
+            b = *src_even++;
+            ++src_even;
+            *dst_y_even++ = (unsigned char)
+                ((( r * 66 + g * 129 + b * 25 + 128 ) >> 8 ) + 16);
+
+            r = *src_odd++;
+            g = *src_odd++;
+            b = *src_odd++;
+            ++src_odd;
+            *dst_y_odd++ = (unsigned char)
+                ((( r * 66 + g * 129 + b * 25 + 128 ) >> 8 ) + 16);
+
+            r = *src_odd++;
+            g = *src_odd++;
+            b = *src_odd++;
+            ++src_odd;
+            *dst_y_odd++ = (unsigned char)
+                ((( r * 66 + g * 129 + b * 25 + 128 ) >> 8 ) + 16);
+        }
+
+        dst_y_odd += width;
+        dst_y_even += width;
+        src_odd += width * 4;
+        src_even += width * 4;
+    }
+
+    return 0;
+}
+
diff --git a/content/media/nsUserMediaConvert.h b/content/media/nsUserMediaConvert.h
new file mode 100644
--- /dev/null
+++ b/content/media/nsUserMediaConvert.h
@@ -0,0 +1,3 @@
+/* Converter functions from libvidcap */
+int RGB32toI420(int width, int height, const char *src, char *dst);
+int I420toRGB32(int width, int height, const char *src, char *dst);
diff --git a/dom/Makefile.in b/dom/Makefile.in
--- a/dom/Makefile.in
+++ b/dom/Makefile.in
@@ -57,16 +57,17 @@ DIRS = \
   interfaces/traversal \
   interfaces/range \
   interfaces/xbl \
   interfaces/xpath \
   interfaces/load-save \
   interfaces/xul \
   interfaces/storage \
   interfaces/json \
+  interfaces/media \
   interfaces/offline \
   interfaces/geolocation \
   interfaces/notification \
   interfaces/svg \
   interfaces/smil \
   $(NULL)
 
 DIRS += \
diff --git a/dom/base/Makefile.in b/dom/base/Makefile.in
--- a/dom/base/Makefile.in
+++ b/dom/base/Makefile.in
@@ -152,16 +152,17 @@ ifdef MOZ_JSDEBUGGER
 DEFINES += -DMOZ_JSDEBUGGER
 endif
 
 ifdef MOZ_B2G_RIL
 DEFINES += -DMOZ_B2G_RIL
 endif
 
 include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/media/webrtc/webrtc-config.mk
 include $(topsrcdir)/ipc/chromium/chromium-config.mk
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES += \
 		-I$(topsrcdir)/js/xpconnect/src \
 		-I$(topsrcdir)/js/xpconnect/wrappers \
 		-I$(topsrcdir)/xpcom/ds \
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -51,16 +51,17 @@
 #include "base/basictypes.h"
 
 #include "Navigator.h"
 #include "nsIXULAppInfo.h"
 #include "nsPluginArray.h"
 #include "nsMimeTypeArray.h"
 #include "nsDesktopNotification.h"
 #include "nsGeolocation.h"
+#include "nsUserMedia.h"
 #include "nsIHttpProtocolHandler.h"
 #include "nsICachingChannel.h"
 #include "nsIDocShell.h"
 #include "nsIWebContentHandlerRegistrar.h"
 #include "nsICookiePermission.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIJSContextStack.h"
 #include "nsCharSeparatedTokenizer.h"
@@ -127,16 +128,17 @@ Navigator::~Navigator()
   Invalidate();
 }
 
 NS_INTERFACE_MAP_BEGIN(Navigator)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigator)
   NS_INTERFACE_MAP_ENTRY(nsIDOMClientInformation)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorGeolocation)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMGetUserMedia)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMozNavigatorBattery)
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorDesktopNotification)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMozNavigatorSms)
 #ifdef MOZ_B2G_RIL
   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorTelephony)
 #endif
   NS_INTERFACE_MAP_ENTRY(nsIDOMMozNavigatorNetwork)
 #ifdef MOZ_B2G_BT
@@ -865,16 +867,38 @@ Navigator::MozIsLocallyAvailable(const n
     return NS_OK;
   }
 
   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
   return httpChannel->GetRequestSucceeded(aIsAvailable);
 }
 
 //*****************************************************************************
+//    Navigator::nsIDOMGetUserMedia, a function not an attribute!
+//*****************************************************************************
+
+NS_IMETHODIMP Navigator::GetUserMedia(const JS::Value& aValue,
+  nsIDOMGetUserMediaSuccessCallback* success,
+  nsIDOMGetUserMediaErrorCallback* error,
+  nsIDOMCanvasRenderingContext2D* canvas)
+{
+  nsCOMPtr<nsPIDOMWindow> win(do_QueryReferent(mWindow));
+  if (!win || !win->GetOuterWindow() || !win->GetDocShell()) {
+    return NS_ERROR_FAILURE;
+  }
+
+  if (!mUserMedia) {
+    mUserMedia = new nsUserMedia();
+  }
+
+  mUserMedia->GetUserMedia(win, aValue, success, error, canvas);
+  return NS_OK;
+}
+
+//*****************************************************************************
 //    Navigator::nsIDOMNavigatorGeolocation
 //*****************************************************************************
 
 NS_IMETHODIMP Navigator::GetGeolocation(nsIDOMGeoGeolocation** _retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = nsnull;
 

diff --git a/dom/base/Navigator.h b/dom/base/Navigator.h
--- a/dom/base/Navigator.h
+++ b/dom/base/Navigator.h
@@ -40,27 +40,29 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_dom_Navigator_h
 #define mozilla_dom_Navigator_h
 
 #include "nsIDOMNavigator.h"
 #include "nsIDOMNavigatorGeolocation.h"
+#include "nsIDOMUserMedia.h"
 #include "nsIDOMNavigatorDesktopNotification.h"
 #include "nsIDOMClientInformation.h"
 #include "nsIDOMNavigatorBattery.h"
 #include "nsIDOMNavigatorSms.h"
 #include "nsIDOMNavigatorNetwork.h"
 #include "nsAutoPtr.h"
 #include "nsWeakReference.h"
 
 class nsPluginArray;
 class nsMimeTypeArray;
 class nsGeolocation;
+class nsUserMedia;
 class nsDesktopNotificationCenter;
 class nsPIDOMWindow;
 class nsIDOMMozConnection;
 
 #ifdef MOZ_B2G_RIL
 #include "nsIDOMNavigatorTelephony.h"
 class nsIDOMTelephony;
 #endif
@@ -91,16 +93,17 @@ class Connection;
 
 namespace power {
 class PowerManager;
 } // namespace power
 
 class Navigator : public nsIDOMNavigator
                 , public nsIDOMClientInformation
                 , public nsIDOMNavigatorGeolocation
+                , public nsIDOMGetUserMedia
                 , public nsIDOMNavigatorDesktopNotification
                 , public nsIDOMMozNavigatorBattery
                 , public nsIDOMMozNavigatorSms
 #ifdef MOZ_B2G_RIL
                 , public nsIDOMNavigatorTelephony
 #endif
                 , public nsIDOMMozNavigatorNetwork
 #ifdef MOZ_B2G_BT
@@ -110,16 +113,17 @@ class Navigator : public nsIDOMNavigator
 public:
   Navigator(nsPIDOMWindow *aInnerWindow);
   virtual ~Navigator();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMNAVIGATOR
   NS_DECL_NSIDOMCLIENTINFORMATION
   NS_DECL_NSIDOMNAVIGATORGEOLOCATION
+  NS_DECL_NSIDOMGETUSERMEDIA
   NS_DECL_NSIDOMNAVIGATORDESKTOPNOTIFICATION
   NS_DECL_NSIDOMMOZNAVIGATORBATTERY
   NS_DECL_NSIDOMMOZNAVIGATORSMS
 #ifdef MOZ_B2G_RIL
   NS_DECL_NSIDOMNAVIGATORTELEPHONY
 #endif
   NS_DECL_NSIDOMMOZNAVIGATORNETWORK
 
@@ -145,16 +149,17 @@ public:
 
 private:
   bool IsSmsAllowed() const;
   bool IsSmsSupported() const;
 
   nsRefPtr<nsMimeTypeArray> mMimeTypes;
   nsRefPtr<nsPluginArray> mPlugins;
   nsRefPtr<nsGeolocation> mGeolocation;
+  nsRefPtr<nsUserMedia> mUserMedia;
   nsRefPtr<nsDesktopNotificationCenter> mNotification;
   nsRefPtr<battery::BatteryManager> mBatteryManager;
   nsRefPtr<power::PowerManager> mPowerManager;
   nsRefPtr<sms::SmsManager> mSmsManager;
 #ifdef MOZ_B2G_RIL
   nsCOMPtr<nsIDOMTelephony> mTelephony;
 #endif
   nsRefPtr<network::Connection> mConnection;
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -436,16 +436,19 @@
 #include "nsIImageDocument.h"
 
 // Storage includes
 #include "nsDOMStorage.h"
 
 // Drag and drop
 #include "nsIDOMDataTransfer.h"
 
+// UserMedia
+#include "nsIDOMUserMedia.h"
+
 // Geolocation
 #include "nsIDOMGeoGeolocation.h"
 #include "nsIDOMGeoPosition.h"
 #include "nsIDOMGeoPositionCoords.h"
 #include "nsIDOMGeoPositionError.h"
 
 // Workers
 #include "mozilla/dom/workers/Workers.h"
@@ -2416,16 +2419,17 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Location, nsIDOMLocation)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMLocation)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Navigator, nsIDOMNavigator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigator)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMGetUserMedia)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNavigatorGeolocation)
     DOM_CLASSINFO_MAP_CONDITIONAL_ENTRY(nsIDOMNavigatorDesktopNotification,
                                         Navigator::HasDesktopNotificationSupport())
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMClientInformation)
     DOM_CLASSINFO_MAP_CONDITIONAL_ENTRY(nsIDOMMozNavigatorBattery,
                                         battery::BatteryManager::HasSupport())
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMMozNavigatorSms)
 #ifdef MOZ_B2G_RIL
diff --git a/dom/interfaces/media/nsIDOMUserMedia.idl b/dom/interfaces/media/nsIDOMUserMedia.idl
new file mode 100644
--- /dev/null
+++ b/dom/interfaces/media/nsIDOMUserMedia.idl
@@ -0,0 +1,74 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2012
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Anant Narayanan <anant@kix.in>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "domstubs.idl"
+#include "nsIDOMCanvasRenderingContext2D.idl"
+
+[scriptable, uuid(2d2d11fc-41ed-4556-b922-79a3aca64b27)]
+interface nsIDOMUserMediaStream : nsISupports
+{
+  void startWithCanvas(in nsIDOMCanvasRenderingContext2D ctx);
+  void stop();
+};
+
+[scriptable, uuid(64334e6b-aaba-4d18-a35e-92239060fb8a)]
+interface nsIDOMGetUserMediaError : nsISupports
+{
+  const unsigned short UNKNOWN_ERROR = 0;
+  const unsigned short PERMISSION_DENIED = 1;
+  readonly attribute short code;
+};
+
+[scriptable, function, uuid(f2a144fc-3534-4761-8c5d-989ae720f89a)]
+interface nsIDOMGetUserMediaSuccessCallback : nsISupports
+{
+  void onSuccess(in nsIDOMUserMediaStream stream);
+};
+
+[scriptable, function, uuid(2614bbcf-85cc-43e5-8740-964f52bdc7ca)]
+interface nsIDOMGetUserMediaErrorCallback : nsISupports
+{
+  void onError(in nsIDOMGetUserMediaError error);
+};
+
+[scriptable, uuid(05083c6a-a35c-4988-ba73-a226540ea5db)]
+interface nsIDOMGetUserMedia : nsISupports
+{
+  void getUserMedia(in jsval options,
+    in nsIDOMGetUserMediaSuccessCallback success,
+    [optional] in nsIDOMGetUserMediaErrorCallback error,
+    [optional] in nsIDOMCanvasRenderingContext2D ctx);
+};
